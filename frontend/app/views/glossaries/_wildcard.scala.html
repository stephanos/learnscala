@()(implicit basePath: String)

@*
    http://www.slideshare.net/normation/scala-dreaded
    http://docs.scala-lang.org/tutorials/FAQ/finding-symbols.html
    http://stackoverflow.com/questions/8000903/what-are-all-the-uses-of-an-underscore-in-scala
*@
@layout.simpledeck("Wildcard") {

    @codesplits((60,40), clazz = "slim"){
        @codesplit() {
            |class WildcardUseCases @("{")
        } {
            @underline("AnwendungsfÃ¤lle:")
        }
        @splitstart() {
            |  import scala.math._
            |  import java.util.{Date => _, _}
            |
        }{
            @li { Importieren }
        }
        @codesplit() {
            |  private var name: String = _
        } {
            @li { Initialisierung }
        }
        @codesplit() {
            |  def sizeOf(l: List[_]) =
            |    l.size
        } {
            @li { existenzielle Parameter }
        }
        @codesplit() {
            |  def mult(m: Int, l: List[Int]) =
            |    l map (m * _)
        } {
            @li { anonyme Funktionen }
        }
        @codesplit() {
            |  def double(nums: Int*): List[Int] =
            |    mult(2, (_: List[Int]))(nums.toList)
        } {
            @li { partiell angewandte Funktion }
        }
        @codesplit() {
            |  def double(l: List[Int]): List[Int] =
            |    double(l: _*)
        } {
            @li { vararg-Expansion }
        }
        @splitend() {
            |  def process(tuple: (_, _)) =
            |    tuple match {
            |      case (0, _) =>
            |      case t: Tuple2[String, _] =>
            |      case _ =>
            |  }
            |@("}")
        } {
            @li { Pattern Matching }
        }
    }
}