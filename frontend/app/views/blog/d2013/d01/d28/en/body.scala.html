<p>
    Exercises are a crucial part of my "Introduction to Scala" training course I developed
    for German-speaking software engineers. Nobody wants to listen to someone else's
    dialog for 8 hours - they want to get a feeling for the new language,
    try out the new syntax, play around with new features.
</p>

<p>
    <strong>
        Designing training exercises
    </strong>
</p>

<p>
    But there is always the problem of making sure that the students are on the right track
    when solving the exercises. Depending on the course's size you can not look
    over everyone's shoulder all the time.
</p>

<p>
    This is where I decided to leverage unit tests: Students can use pre-written tests
    to work through the exercises step by step, knowing immediately whether they are
    doing something wrong. This prevents bad surprises when the
    results are shared and discussed in the end.
</p>

<p>
    <strong>
        Adding macros to it
    </strong>
</p>

<p>
    So, I hear you ask, what does that have to do with macros? Scala macros allow you to
    make certain tests that were not possible before.
</p>

<table>
    <tr>
        <td>
            <script src="https://gist.github.com/4643260.js"></script>
        </td>
        <td style="vertical-align: top; padding-left: 20px;">
            <p>
                The snippet on the left illustrates an exercise to teach pattern matching.
                In the presentation the students listened to earlier,
                various patterns like the alternative and wildcard pattern were introduced.
            </p>

            <p>
                The exercise description declares:
                <strong>Rewrite this code in 3 lines or less</strong>. This way
                students have to think about how to apply the new features.
            </p>

            <p>
                Furthermore, they were taught that a <strong>var</strong> should be
                used sparsely. The unit test is able to check for this as well.
            </p>

            <p>
                So macros allow to test various code styles and metrics, cool!
            </p>
        </td>
    </tr>
</table>

<p>
    <strong>
        How it works
    </strong>
</p>

<p>
    Behind the scenes the unit tests use
    <a href="http://docs.scala-lang.org/overviews/macros/overview.html" target="_blank">
        def macros</a>, since type macros are only available in an experimental Scala 2.11 branch.
    First I thought it may not be possible with this limitation, but thanks to the help
    of Eugene Burmako - member of the official Scala team - it worked out great.
</p>

<p>
    The method <strong>task</strong> - part of the trait <strong>Testable</strong>
    that each exercise inherits from - calls a macro. Then it gets interesting. Since def macros
    cannot add fields or methods to existing classes I had to create a base class
    <strong>Task</strong> with all fields I would later need, e.g. to count the number of
    <strong>vars</strong> the code uses.
<p>

<table>
    <colgroup>
        <col width="40%">
        <col width="60%">
    </colgroup>
    <tr>
        <td>
            <script src="https://gist.github.com/4643398.js"></script>
        </td>
        <td style="vertical-align: top; padding-left: 20px;">
            <script src="https://gist.github.com/4647618.js"></script>
        </td>
    </tr>
</table>

<p>
    Then the macro would generate a call to the method <strong>registerTask</strong> that
    takes an instance of type <strong>Task</strong>. Since the fields are already declared
    they can simply be overridden by the macro on instantiation. Et voil√†!
</p>

<p>
    The complete macro code is rather ugly and contains a few workarounds, but the following
    snippet shows the small part where the number of <strong>vars</strong> is determined
    and the method to actually overwrite the field.
</p>

<p>
    <script src="https://gist.github.com/4647666.js"></script>
</p>

<p>
    All in all the macro worked pretty well in my last Scala training. The students
    where quite astonished when the length and style of their solutions were judged.
    I think it's a great way of making sure the students adhere to the rules and
    concepts they just learned about; preventing them to just stick with their old
    Java habits.
</p>

<p>
    I'm looking forward to the possibilities the type macros will bring in 2.11.
    Thanks for reading.
</p>