@slide(title = "Collections") {

    @sidebyside() {
        @snippet() {
            @callblock(fragment = false, id = "nums") {
                |val nums = List(1, 2, 3)
            }
            @outblock() {
                |nums: List[Int] = List(1, 2, 3)
            }
            @callblock() {
                |nums map { (x: Int) => x + 1 }
            }
            @outblock() {
                |res0: List[Int] = List(2, 3, 4)
            }
        }
    } {
        <div class="indent">
            <ul>
                <li class="fragment">
                    Funktion "erhöhe Wert um 1" wird auf jedes Element angewendet; Resultat ist eine neue Liste
                </li>
                <li class="fragment">
                    Aufruf der Methode <code>map</code> mit einem <em>Funktionsliteral</em> (anonyme Funktion) als Argument
                </li>
                <li class="fragment">
                    Syntax des Funktionsliterals ähnlich der einer Methode:
                    Parameterliste <code>(x: Int)</code> und Körper <code>x + 1</code> getrennt durch <code>=></code>
                </li>
                <li class="fragment">
                    übliche Schreibweise: ohne Punkt und mit geschweiften Klammern
                </li>
            </ul>
        </div>
    }
}


@slide() {

    @sidebyside() {
        @snippet() {
            @callblock(reference = "nums", fragment = false) {
                |nums filter { (x: Int) => x < 3 }
            }
            @outblock() {
                |res0: List[Int] = List(1, 2)
            }
        }
    } {
        <div class="indent">
            <ul>
                <li class="fragment">
                    Funktion "ist x kleiner als 3" wird auf jedes Element angewendet;
                    ist das Ergebnis <code>true</code> wird es ins Resultat übernommen
                </li>
                <li class="fragment">
                    <code>map</code> und <code>filter</code> sind <em>Funktionen höherer Ordnung</em>
                    ("higher-order functions"): Argument oder Rückgabewert sind wiederum Funktion
                </li>
                <li class="fragment">
                    Eigenschaften einer Funktion:
                    @spacer()
                    <ul>
                        <li class="fragment">
                            frei von Seiteneffekten
                        </li>
                        <li class="fragment">
                            hat ein Ergebnis (nicht <code>Unit</code>)
                        </li>
                        <li class="fragment">
                            gleiches Ergebnis für gleiche Argumente
                        </li>
                    </ul>
                </li>
            </ul>
        </div>
    }
}


@slide() {
    <!-- Funktionsliteral: ohne Typ -->

    @sidebyside() {
        @snippet() {
            @callblock(reference = "nums", fragment = false) {
                |nums map { x => x + 1 }
            }
            @outblock() {
                |res0: List[Int] = List(2, 3, 4)
            }
        }
    } {
        <div class="indent">
            <ul>
                <li class="fragment">
                    Typ von <code>x</code> kann weggelassen werden
                </li>
                <li class="fragment">
                    abgeleitet vom Typ-Parameter der Liste (<code>Int</code>)
                    und der Signatur der Methode <code>map</code>
                </li>
            </ul>
        </div>
    }

    @spacer2()

    @sidebyside() {
        @sourcecode() {
            |trait Traversable[A] {
            |  def map[B](f: (A) => B): Traversable[B]
            |}
        }
    } {
        <div class="indent">
            <ul>
                <li class="fragment">
                    <code>map</code> transformiert die Elemente mit Typ <code>A</code>
                    in eine neue Instanz von <code>Traversable</code> mit Typ <code>B</code>
                </li>
            </ul>
        </div>
    }
}


@slide() {
    <!-- Funktionsliteral: ohne Parameterliste -->

    @sidebyside() {
        @snippet() {
            @callblock(reference = "nums", fragment = false) {
                |nums filter { _ < 3 }
            }
            @outblock() {
                |res0: List[Int] = List(1, 2)
            }
            @callblock() {
                |nums filter { _ > 0 && _ < 3 }
            }
            @outblock(error = true) {
                |error: wrong number of parameters;
                |       expected = 1
            }
        }
    } {
        <div class="indent">
            <ul>
                <li class="fragment">
                    Parameterliste kann weggelassen werden;
                    mit <code>_</code> kann jeder Parameter einmal referenziert werden
                </li>
            </ul>
        </div>
    }

    @spacer2()

    @sidebyside() {
        @snippet() {
            @callblock(reference = "nums") {
                |nums sortWith { (x, y) => x > y }
            }
            @outblock() {
                |res0: List[Int] = List(3, 2, 1)
            }
            @callblock() {
                |numbers sortWith { _ > _ }
            }
            @outblock() {
                |res1: List[Int] = List(3, 2, 1)
            }
        }
    } {
        <div class="indent">
            <ul>
                <li class="fragment">
                    Funktion "ist x größer als y" wird auf jedes Element angewendet
                </li>
                <li class="fragment">
                    der erste <code>_</code> repäsentiert den ersten Parameter (x),
                    der zweite <code>_</code> den zweiten Parameter (y)
                </li>
            </ul>
        </div>
    }
}


@quiz() {
    @Quiz.collection()
}