@*
    Try: http://coderwall.com/p/qe0uca
*@
@defining(Content.ausblick.label) { implicit topic =>

    @layout.slidedeck(topic) {

        @slidehead() {
            @topic
        } {

        }

        <!-- ################################################################################## -->

        @*
        @titleslide("Testen") {
            @snippet() {
                @sourceblock() {
                    |import org.specs2.mutable._
                    |
                    |class HelloWorldSpec extends Specification {
                    |
                    |   "The 'Hello world' string" should {
                    |
                    |       "contain 11 characters" in {
                    |           "Hello world" must have size(11)
                    |       }
                    |       "start with 'Hello'" in {
                    |           "Hello world" must startWith("Hello")
                    |       }
                    |       "end with 'world'" in {
                    |           "Hello world" must endWith("world")
                    |       }
                    |   }
                    |}
                }
            }
        }
        *@

        <!-- ################################################################################## -->

        @titleslide("XML") {
            @snippet() {
                @sourceblock() {
                    |class XML(title: String) {
                    |
                    | val page =
                    |  &lt;html&gt;
                    |    &lt;head&gt;
                    |      &lt;title&gt;{title}&lt;/title&gt;
                    |    &lt;/head&gt;
                    |    &lt;body&gt;
                    |      &lt;h1&gt;{title}&lt;/h1&gt;
                    |      &lt;p&gt;&lt;a href="scala-lang.org"&gt;Scala&lt;/a&gt; talks XHTML&lt;/p&gt;
                    |    &lt;/body&gt;
                    |  &lt;/html&gt;
                    |}
                }
                @callblock() {
                    |println(new XML("Hello World").page.toString())
                }
            }
        }

        <!-- ################################################################################## -->

        @*
        @titleslide("Swing") {
            @sourcecode() {
                |object SwingApp extends SimpleSwingApplication {
                |
                |  def top = new MainFrame {
                |    title = "SwingApp"
                |    var numclicks = 0
                |
                |        object label extends Label {
                |            val prefix = "Number of button clicks: "
                |            text = prefix + "0  "
                |            listenTo(button)
                |            reactions += {
                |                case ButtonClicked(button) =>
                |                    numclicks = numclicks + 1
                |                    text = prefix + numclicks
                |            }
                |        }
                |
                |        object button extends Button {
                |           text = "I am a button"
                |       }
                |
                |       contents = new FlowPanel {
                |          contents.append(button, label)
                |          border = Swing.EmptyBorder(5, 5, 5, 5)
                |        }
                |    }
                |}
            }
        }
        *@

        <!-- ################################################################################## -->

        @titleslide("Collections II") {
            @sourcecode() {
                |// sequentiell:
                |listOfFiles foreach (file => sendToS3(file))
            }

            @spacer()

            @sourcecode() {
                |// parallel
                |listOfFiles.par foreach (file => sendToS3(file))
            }

            @spacer2()

            @snippet() {
                @sourceblock() {
                    |// lazy
                    |lazy val fib: Stream[Int] = Stream.cons(0, Stream.cons(1,
                    |                                fib.zip(fib.tail).map(p => p._1 + p._2)))
                }
                @callblock() {
                    |fib.take(15).print
                }
            }
        }

        <!-- ################################################################################## -->

        @titleslide("Either") {
            @sourcecode() {
                 |def toInt (s: String): Either[String,Int] = {
                 |  try {
                 |     Right (s.toInt)
                Â |  }
                 |  catch {
                 |    case e: Throwable =>
                 |      Left ("Error: " + e.getMessage)
                 |  }
                 |}
            }

            @spacer()

            @indent() {
                @snippet() {
                    @callblock() {
                        |toInt ("1")
                    }
                    @outblock() {
                        |res0: Either[String,Int] = Right(1)
                    }
                    @callblock() {
                        |toInt ("a")
                    }
                    @outblock() {
                        |res1: Either[String,Int] = Left(Error: For input string: "a")
                    }
                }
            }
        }

        <!-- ################################################################################## -->

        @titleslide("Cake Pattern") {
            @sidebyside() {
                @sourcecode() {
                    |trait DatabaseContext {
                    |  val dataSource: Datasource
                    |}
                }
                @spacer_half()
                @sourcecode() {
                    |trait OrderRepoComp {
                    |  this: DatabaseContext =>
                    |
                    |  trait OrderRepoImpl {
                    |    // ...
                    |  }
                    |  val orderRepo: OrderRepoImpl
                    |}
                }
                @spacer_half()
                @sourcecode() {
                    |trait ProductRepoComp {
                    |  this: DatabaseContext =>
                    |
                    |  trait ProductRepoImpl {
                    |    // ...
                    |  }
                    |  val productRepo: ProductRepoImpl
                    |}
                }
            } {
                @spacer()

                @sourcecode() {
                    |object Registry extends OrderRepoComp
                    |                with ProductRepoComp
                    |                with DatabaseContext {
                    |
                    |  val orderRepo = new OrderRepoImpl
                    |  val dataSource = new DatasourceImpl
                    |  val productRepo = new ProductRepoImpl
                    |}
                }
            }
        }

        <!-- ################################################################################## -->

        <!--
            TODO: add tutego courses
        -->

        @slide() {
            @spacer2()@spacer()

            <div class="dcenter tcenter">
                <h1>
                    The End <em class="fragment">?</em>
                </h1>

                @spacer()

                <h3>
                    teilnehmer.foreach(t => println("Bye " + t))
                </h3>
            </div>
        }
    }
}
