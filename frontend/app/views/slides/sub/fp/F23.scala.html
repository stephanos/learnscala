<!--
    TODO
        - good flatMap & Option example
-->
@implicitSlide = @{ Content.funktionen3 }

@defining(implicitSlide.label) { implicit topic =>

    @layout.slidedeck(topic) {

        @slidehead() {
            @topic
        } {
            @image("fx.png", clazz = "naked", height = 200)
            @spacer_half()
            Funktionen und Kollektionen
        }

        <!-- ################################################################################## -->

        @defining("HOF") { title =>

            @defining("foreach") { subtitle =>

                @headslide(title = title, subtitle = subtitle) {
                    @subtitle
                } {
                    @sourcecode() {
                        |trait Traversable[A] {
                        |  def foreach[A](f: Elem => A): Unit
                        |}
                    }
                    @codesub2() {
                        führt Funktion auf jedes Element aus
                    }

                    @spacer2()

                    @snippet() {
                        @callblock() {
                            |val nums = List(1, 2, 3, 4)
                            |
                            |nums foreach { n => println(n) }
                        }
                        @outblock() {
                            |1
                            |2
                            |3
                            |4
                        }
                    }
                    @codesub2() {
                        Ausgabe aller Elemente
                    }
                }

                @notes {
                    - [STIL] infix-Notation bevorzugen
                }
            }

            <!-- ################################################################################## -->

            @defining("filter") { subtitle =>

                @headslide(title = title, subtitle = subtitle) {
                    @subtitle
                } {
                    @autocenter {
                        @sourcecode() {
                            |trait Traversable[A] {
                            |  def filter(f: A => Boolean): Traversable[A]
                            |}
                        }
                        @codesub2() {
                            überführt Elemente, für die <code>f</code> wahr ist, in eine neue Liste
                        }
                    }

                    @spacer()

                    @sidebyside(gap = 10) {
                        @snippet() {
                            @callblock(reference = "nums") {
                                |nums filter { n => n % 2 == 0 }
                            }
                            @outblock() {
                                |res0: List[Int] = List(2, 4)
                            }
                        }
                        @codesub2() {
                            Liste der geraden Zahlen
                        }
                    } {
                        @snippet() {
                            @callblock(reference = "nums") {
                                |nums filter { n =>
                                |   val isEven = (n % 2 == 0)
                                |   println(n + "? " + isEven)
                                |   isEven
                                |}
                            }
                            @outblock() {
                                |1? false
                                |2? true
                                |3? false
                                |4? true
                                |res0: List[Int] = List(2, 4)
                            }
                        }
                        @codesub2() {
                            mit Zwischenschritten
                        }
                    }
                }
            }

            <!-- ################################################################################## -->

            @defining("map") { subtitle =>

                @headslide(title = title, subtitle = subtitle) {
                    @subtitle
                } {
                    @autocenter {
                        @sourcecode() {
                            |trait Traversable[A] {
                            |  def map[B](f: (A) => B): Traversable[B]
                            |}
                        }
                        @codesub2() {
                            wendet Funktion auf jedes Element an und liefert Ergebnisliste
                        }
                    }

                    @spacer()

                    @sidebyside(gap = 10) {
                        @snippet() {
                            @callblock(reference = "nums") {
                                |nums map { n => n * 2 }
                            }
                            @outblock() {
                                |res0: List[Int] = List(2, 4, 6, 8)
                            }
                        }
                        @codesub2() {
                            Liste mit verdoppelten Werten
                        }
                    } {
                        @snippet() {
                            @callblock(reference = "nums") {
                                |nums map { n =>
                                |   val res = (n * 2)
                                |   println(n + " => " + res)
                                |   res
                                |}
                            }
                            @outblock() {
                                |1 => 2
                                |2 => 4
                                |3 => 6
                                |4 => 8
                                |res0: List[Int] = List(2, 4, 6, 8)
                            }
                        }
                        @codesub2() {
                            mit Zwischenschritten
                        }
                    }
                }
            }

            <!-- ################################################################################## -->

            @headslide(title = title, subtitle = "Weitere") {
                usw.
            } {
                @sidebyside(gap = 10) {
                    @snippet() {
                        @callblock(reference = "nums") {
                            |nums partition { n => n % 2 == 0 }
                        }
                        @outblock() {
                            |res0: (List[Int], List[Int]) =
                            |  (List(2, 4),List(1, 3))
                        }
                    }
                    @codesub2() {
                        teilt Liste nach Wahrheitswert der Funktion
                    }

                    @spacer()

                    @snippet() {
                        @callblock(reference = "nums") {
                            |nums exists { n => n % 4 == 0 }
                        }
                        @outblock() {
                            |res0: Boolean = true
                        }
                    }
                    @codesub2() {
                        überprüft ob ein Element die Bedingung erfüllt
                    }

                    @spacer()

                    @snippet() {
                        @callblock(reference = "nums") {
                            |nums zipWithIndex
                        }
                        @outblock() {
                            |res0: List[(Int, Int)] =
                            |  List((1,0), (2,1), (3,2), (4,3))
                        }
                    }
                    @codesub2() {
                        erstellt Liste aus Tupeln aus Element und Index
                    }

                } {
                    @snippet() {
                        @callblock(reference = "nums") {
                            |nums groupBy { n => n % 2 }
                        }
                        @outblock() {
                            |res0: Map[Int,List[Int]] =
                            |  Map(1 -> List(1, 3), 0 -> List(2, 4))
                        }
                    }
                    @codesub2() {
                        gruppiert Elemente
                    }

                    @spacer()

                    @snippet() {
                        @callblock(reference = "nums") {
                            |nums takeWhile { n => n <= 2 }
                        }
                        @outblock() {
                            |res0: List[Int] = List(1, 2)
                        }
                    }
                    @codesub2() {
                        extrahiert Teilliste für die die Funktion wahr ist
                    }

                    @spacer()

                    @snippet() {
                        @callblock() {
                            |List(List(1, 2), List(3, 4)).flatten
                        }
                        @outblock() {
                            |res0: List[Int] = List(1, 2, 3, 4)
                        }
                    }
                    @codesub2() {
                        'plättet' eine Liste aus Listen
                    }
                }
            }
        }

        <!-- ################################################################################## -->

        @quiz() {
            @Quiz.functions3()
        }

        <!-- ################################################################################## -->

        @titleslide(title = "Beispiel") {

            @sidebyside() {
                @sourcecode(reference = "person") {
                    |def separate(persons: List[Person]) = {
                    |  import scala.collection.mutable._
                    |
                    |  var boys, men = ListBuffer[Person]()
                    |  for (i <- 0 to persons.length - 1)
                    |    if (persons(i).age < 18)
                    |      boys += persons(i)
                    |    else
                    |      men += persons(i)
                    |
                    |  var boyNames,
                    |      menNames = ListBuffer[String]()
                    |  for (i <- 0 to sortedBoys.length - 1)
                    |    boyNames += boys(i).name
                    |  for (i <- 0 to sortedMen.length - 1)
                    |    menNames += men(i).name
                    |
                    |  (boyNames.toList, menNames.toList)
                    |}
                }
                @codesub2() {
                    <var>Java</var>-Stil: Veränderlichkeit, Redundanz und Schleifen
                }
            } {
                @sourcecode(reference = "person") {
                    |def separate(persons: List[Person]) = {
                    |
                    |  def mapToName(ppl: List[Person]) =
                    |    ppl.map(p => p.name)
                    |
                    |  val (boys, men) =
                    |    persons.partition(p => p.age < 18)
                    |
                    |  (mapToName(boys), mapToName(men))
                    |}
                }
                @codesub2() {
                    <em>Scala</em>-Stil: Funktionen
                }
            }

            @notes {
                - [ASK] Was macht dieser Code?
                - [HINT] '-1' Fehler
                - [BP] Zwischenergebnise & -methoden verwenden! erhöht Lesbarkeit!
            }
        }

        @*
        @slide() {
            def getTemporaryDirectory(tmpArg: Option[String]): java.io.File = {
           ￼￼
           tmpArg.map(name => new java.io.File(name)).
               filter(_.isDirectory).
               getOrElse(new java.io.File(
                 System.getProperty("java.io.tmpdir")))
           Create if defined Only directories
           Specify default
           ￼￼￼￼￼￼}
        }
        *@

        <!-- ################################################################################## -->

        @uebung(implicitSlide.id + "_1")

        <!-- ################################################################################## -->

        <!-- TODO: Currying -->

        <!-- ################################################################################## -->

        @defining("foldLeft") { title =>

            @titleslide(title = title) {

                @*
                println((1 to 1000000) reduceLeft(_ + _))  // tail rec
                println((1 to 1000000) reduceRight(_ + _)) // overflow
                *@

                @autocenter {
                    @sourcecode() {
                        |trait Traversable[A] {
                        |  def foldLeft[B](z: B)(f: (B, A) => B): B
                        |}
                    }
                    @codesub2() {
                        transformiert Elemente vom Typ <code>A</code> in Ergebnis vom Typ <code>B</code>
                    }
                }

                @spacer()

                @sidebyside(gap = 10) {

                    @snippet() {
                        @callblock(reference = "nums") {
                            |nums foldLeft(0) { (res, num) =>
                            |  res + num
                            |}
                        }
                        @outblock() {
                            |res0: Int = 10
                        }
                    }
                    @codesub2() {
                        Summe der Elemente
                    }
                } {
                    @snippet() {
                        @callblock(reference = "nums") {
                            |nums foldLeft(0) { (res, num) =>
                            |  println("= " + res + " + " + num)
                            |  res + num
                            |}
                        }
                        @outblock() {
                            |= 0 + 1
                            |= 1 + 2
                            |= 3 + 3
                            |= 6 + 4
                            |res1: Int = 10
                        }
                    }
                    @codesub2() {
                        mit Zwischenergebnissen
                    }
                }
            }
        }

        <!-- ################################################################################## -->

        @uebung(implicitSlide.id + "_2")

        <!-- ################################################################################## -->

        @defining("flatMap") { title =>

            @titleslide(title = title) {

                @sidebyside(gap = 10) {

                    @subhead() {
                        (A) Systemparameter auslesen
                    }

                    @snippet() {
                        @sourceblock(id = "config") {
                            |def getConf(s: String) =
                            |  Option(System getProperty s)
                        }
                        @outblock() {
                            |getConf: (s: String)Option[String]
                        }
                    }
                } {
                    @subhead() {
                        (B) <code>String</code> in <code>Float</code> umwandeln
                    }

                    @snippet() {
                        @sourceblock(id = "tonum", reference = "config") {
                            |def toNum(s: String) =
                            |  try { Some(s toFloat) }
                            |  catch {
                            |    case e: Throwable => None
                            |  }
                        }
                        @outblock() {
                            |toNum: (s: String)Option[Float]
                        }
                    }
                }

                @spacer()

                @autocenter {
                    @snippet() {
                        @callblock(reference = "tonum") {
                            |val n = "java.specification.version"
                            |val r1 = getConf(n) map { s => toNum(s) }
                        }
                        @outblock() {
                            |r1: Option[Option[Float]] = Some(Some(1.6))
                        }
                        @callblock() {
                            |val r2 = getConf(n) flatMap { s => toNum(s) }
                        }
                        @outblock() {
                            |r2: Option[Float] = Some(10.6)
                        }
                    }
                    @codesub2() {
                        <em>flatMap</em> 'plättet' das Ergebnis
                    }
                }
            }

            <!-- ################################################################################## -->

            @titleslide(title = title) {

                @autocenter {
                    @sourcecode() {
                        |trait Traversable[A] {
                        |  def flatMap[B](f: A => Traversable[B]): Traversable[B]
                        |}
                    }
                }

                @spacer2()

                @sidebyside() {
                    @snippet() {
                        @callblock() {
                            |(1 to 4) flatMap { n => empl get n }
                        }
                        @outblock() {
                            |res0: IndexedSeq[String] = Vector(Adam)
                        }
                    }
                    @codesub2() {
                        Mitarbeiter mit ID von 1 bis 4
                    }
                } {
                    @snippet() {
                        @callblock() {
                            |(1 to 4) flatMap { n =>
                            |  val e = empl get n
                            |  println(e)
                            |  e
                            |}
                        }
                        @outblock() {
                            |Some(Adam)
                            |None
                            |None
                            |None
                            |res0: IndexedSeq[String] = Vector(Adam)
                        }
                    }
                    @codesub2() {
                        mit Zwischenergebnissen
                    }
                }

                @*
                @snippet() {
                    @callblock() {
                        |TODO
                    }
                    @outblock() {
                        |res0:
                    }
                }
                @codesub2() {
                    TODO
                }
                *@

                @notes {
                    - [PS] 'empl' is defined but hidden
                }
            }
        }

        <!-- ################################################################################## -->

        @*
        @slide(title = "Beispiel") {

            @sidebyside(gap = 10) {
                @sourcecode(id = "empl") {
                    |case class Empl (
                    |   name: String,
                    |   age: Int,
                    |   started: Int,
                    |   nickname: Option[String] = None
                    |)
                    |
                    |val empl = List(
                    |    Empl ("Adam", 42, 20),
                    |    Empl ("Bob",  32, 10, Some("Mr B")),
                    |    Empl ("Carl", 46,  6),
                    |    Empl ("Dan",  22,  3),
                    |    Empl ("Ed",   51, 27),
                    |    Empl ("Fred", 24, 10),
                    |    Empl ("Gus",  31,  9, Some("Kingpin")),
                    |    Empl ("Han",  39,  6),
                    |    Empl ("Ian",  23, 15),
                    |    Empl ("Jim",  59, 19, Some("J")),
                    |    Empl ("Kurt", 41,  8, Some("K")),
                    |    Empl ("Liam", 60, 40),
                    |    Empl ("Mel",  65, 10),
                    |    Empl ("Nina", 47,  4, Some("El Nino")),
                    |    Empl ("Otis", 34,  8),
                    |    Empl ("Pia",  31, 12)
                    |)
                }
            } {
                @snippet() {
                    @callblock(reference = "empl") {
                        |empl filter { e =>
                        |    e.started > 20
                        |  } map { e =>
                        |    (e, e.age - e.started)
                        |  } foreach { t =>
                        |    println(t._1.name +
                        |      " started at age " + t)
                        |  }
                    }
                    @outblock() {
                        |Ed started at age 24
                        |Liam started at age 20
                    }
                }

                @spacer()

                @snippet() {
                    @callblock(reference = "empl") {
                        |empl filter { e =>
                        |    e.started > 20
                        |  } map { e =>
                        |    (e, e.age - e.started)
                        |  } foreach { t =>
                        |    println(t._1.name +
                        |      " started at age " + t)
                        |  }
                    }
                    @outblock() {
                        |Ed started at age 24
                        |Liam started at age 20
                    }
                }
            }
        }
        *@
    }
}

@snippet(id = "nums") {
    @callcode() {
        |val nums = List(1, 2, 3, 4)
    }
}

@snippet(id = "empl") {
    @callcode() {
        |val empl = Map(1 -> "Adam", 5 -> "Bob", 9 -> "Carl")
    }
}

@snippet(id = "person") {
    @sourceblock() {
        |case class Person(val name: String, val age: Int)
    }
    @callcode() {
        |val persons = List(
        |   Person("Bob", 42), Person("Jim", 14),
        |   Person("Joe", 12), Person("Alex", 25)
        |)
        |
        |separate(persons)
    }
}