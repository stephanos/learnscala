@defining("For-Ausdruck") { implicit topic =>

    @layout.slidedeck(topic) {

        @slidehead() {
            @topic
        } {
        }

        <!-- ################################################################################## -->

        @defining("Syntax") { title =>
            @slide(title = title) {
                @sidebyside((40,60)) {
                    @sourcecode() {
                        |for (sequence) expression
                    }

                    @spacer()

                    @sourcecode() {
                        |for (seq_0; seq_1; .. ; seq_n) {
                        |  expression
                        |}
                    }

                    @spacer_half()

                    @sourcecode() {
                        |for {
                        |  seq_0
                        |  seq_1
                        |  ..
                        |  seq_n
                        |} {
                        |  expression
                        |}
                    }

                    @spacer()

                    @sourcecode() {
                        |for (sequence) {
                        |  expr_0
                        |  expr_1
                        |  ..
                        |  expr_n
                        |}
                    }
                } {
                    @codenote() {
                        Jeder for-Ausdruck besteht aus 2 Bestandteilen:
                        @spacer()
                        <ol class="indent">
                            <li class="fragment">
                                Sequenz aus
                                @spacer_half()
                                <ul>
                                    <li><em>Generatoren</em></li>
                                    <li><em>Definitionen</em></li>
                                    <li><em>Filtern</em></li>
                                </ul>
                            </li>
                            @spacer_half()
                            <li class="fragment">
                                <em>Ausdruck</em>
                            </li>
                        </ul>
                    }
                }
            }
        }

        <!-- ################################################################################## -->

        @defining("Generator") { title =>

            @headslide(title = title) {
                @title
            } {
                @sidebyside((60,40)) {
                    @sourcecode() {
                        |for (variable <- collection) {
                        |  ...
                        |}
                    }
                } {
                    @codenote() {
                        <code>variable</code> wird schrittweise jedes Element aus <code>collection</code> zugewiesen
                    }
                }

                @spacer2()

                @sidebyside((60,40)) {
                    @snippet() {
                        @sourceblock() {
                            |for (i <- 1 to 10) {
                            |  print(i + " ")
                            |}
                        }
                        @outblock() {
                            |1 2 3 4 5 6 7 8 9 10
                        }
                    }
                } {
                    @codenote() {
                        Methode <code>to</code> erstellt Kollektion mit Zahlen von 1 bis 10
                    }
                }

                @spacer()

                @sidebyside((60,40)) {
                    @snippet() {
                        @sourceblock() {
                            |for (i <- "Hello") print(i + " ")
                        }
                        @outblock() {
                            |H e l l o
                        }
                    }
                } {
                    @codenote() {
                        String <code>Hello</code> ist eine Kollektion aus Zeichen
                    }
                }
            }

            <!-- ################################################################################## -->

            @headslide(title = title) {
                @title
            } {
                @sidebyside((60,40)) {
                    @sourcecode() {
                        |for (var1 <- collect1; var2 <- collect2) {
                        |  ...
                        |}
                    }
                } {
                    @codenote() {

                    }
                }

                @spacer2()

                @sidebyside((60,40)) {
                    @snippet() {
                        @sourceblock() {
                            |for (i <- 1 to 3; j <- 1 to 3)
                            |  print (i, j)
                        }
                        @outblock() {
                            |(1,1)(1,2)(1,3)(2,1)(2,2)(2,3)(3,1)(3,2)(3,3)
                        }
                    }
                } {
                    @codenote() {
                        2. Generator entspricht einer inneren Schleife
                    }
                }

                @spacer()
            }
        }

        <!-- ################################################################################## -->

        @defining("Definition") { title =>

            @headslide(title = title) {
                @title
            } {
                @sidebyside((61,39)) {
                    @snippet() {
                        @sourceblock() {
                            |for (i <- 1 to 10; double = i * 2)
                            |  print (double + " ")
                        }
                        @outblock() {
                            |2 4 6 8 10 12 14 16 18 20
                        }
                    }
                } {
                    @codenote() {
                        Mit Definitionen sind Wertzuweisungen, mit ihnen können neue Variablen definiert werden
                    }
                }

                @spacer()

                @sidebyside((61,39)) {
                    @snippet() {
                        @sourceblock() {
                            |for (i <- 1 to 2; double = i * 2; j <- i to double)
                            |  print (j, double)
                        }
                        @outblock() {
                            |(1,2)(2,2)(2,4)(3,4)(4,4)
                        }
                    }
                } {
                    @codenote() {
                        Definitionen können in beiden Blöcken verwendet werden
                    }
                }

                @spacer()

                @sidebyside((61,39)) {
                    @snippet() {
                        @sourceblock() {
                            |for (i <- 1 to 10; prev = i - 1; next = i + 1)
                            |  print (prev, next)
                        }
                        @outblock() {
                            |(0,2)(1,3)(2,4)(3,5)(4,6)(5,7)(6,8)(7,9)(8,10)(9,11)
                        }
                    }
                } {
                    @codenote() {
                        Definitionen können beliebig oft verwendet werden
                    }
                }
            }
        }

        <!-- ################################################################################## -->

        @defining("Filter") { title =>

            @headslide(title = title) {
                @title
            } {

                @sidebyside((60,40)) {
                    @snippet() {
                        @sourceblock() {
                            |for (i <- 1 to 10; if i % 2 == 0)
                            |  print (i + " ")
                        }
                        @outblock() {
                            |2 4 6 8 10
                        }
                    }
                } {
                    @codenote() {
                        Filter ist ein Ausdruck vom Typ <code>Boolean</code>
                        und entfernt Elemente des Generators für die der Ausdruck unwahr ist
                    }
                }

                @spacer()

                @sidebyside((60,40)) {
                    @snippet() {
                        @sourceblock() {
                            |for {
                            |  i <- 1 to 10
                            |  if i % 2 == 0
                            |  if i % 3 == 0
                            |} print (i + " ")
                        }
                        @outblock() {
                            |6
                        }
                    }
                } {
                    @codenote() {
                        Mehrere Filter werden einfach sequentiell angewandt
                    }
                }

                @spacer()

                @sidebyside((60,40)) {
                    @snippet() {
                        @sourceblock() {
                            |for {
                            |  i <- 1 to 10         // Generator
                            |  sqrt = Math.sqrt(i)  // Definition
                            |  if sqrt % 3 == 0     // Filter
                            |} print (i + " ")
                        }
                        @outblock() {
                            |9
                        }
                    }
                } {
                    @codenote() {
                        Filter können Bezug auf Definitionen nehmen
                    }
                }
            }
        }

        <!-- ################################################################################## -->

        @defining("Yield") { title =>

            @headslide(title = title) {
                @title
            } {
                @sidebyside((75,25)) {
                    @snippet() {
                        @sourceblock() {
                            |for {
                            |  i <- 1 to 10
                            |} yield i
                        }
                        @outblock() {
                            |res0: IndexedSeq[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
                        }
                    }
                } {
                    @codenote() {
                        <code>yield</code> gibt dem for-Ausdruck einen Rückgabewert
                    }
                }

                @spacer()

                @sidebyside((75,25)) {
                    @snippet() {
                        @sourceblock() {
                            |for {
                            |  i <- 1 to 10
                            |} yield {
                            |  val r = i + 1
                            |  r
                            |}
                        }
                        @outblock() {
                            |res0: IndexedSeq[Int] = Vector(2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
                        }
                    }
                } {
                }
            }
        }

        <!-- ################################################################################## -->

        @defining("Beispiel") { title =>

            @slide(title = title) {
                @sourcecode(id = "people") {
                    |val ppl = List("Anna" -> "Adams", "Adam" -> "Adams", "Barb" -> "Brown", "Bill" -> "Brown")
                }

                @spacer()

                @fragment {
                    <div class="tcenter">
                        <span class="big underline">
                            Vornamen die mit "B" beginnen ?
                        </span>
                    </div>
                }

                @spacer()

                @sidebyside((50,50)) {
                    @snippet() {
                        @callblock(reference = "people") {
                            |for {
                            |  p <- ppl                   // Generator
                            |  firstname = p._1           // Definition
                            |  if p._1.startsWith("B")    // Filter
                            |} print(firstname + " ")
                        }
                        @outblock() {
                            |Barb Bill
                        }
                    }
                    @codesub() {
                        Ausgabe via for-Ausdruck
                    }
                } {
                    @snippet() {
                        @callblock(reference = "people") {
                            |ppl filter {
                            |  p =>
                            |    val firstname = p._1
                            |    firstname.startsWith("B")
                            |} foreach {p => print(p._1 + " ")}
                        }
                        @outblock() {
                            |Barb Bill
                        }
                    }
                    @codesub() {
                        Ausgabe via Funktionen höherer Ordnung
                    }
                }

                @spacer()

                @sidebyside((50,50)) {
                    @snippet() {
                        @callblock(reference = "people") {
                            |for {
                            |  p <- ppl                   // Generator
                            |  firstname = p._1           // Definition
                            |  if p._1.startsWith("B")    // Filter
                            |} yield firstname
                        }
                        @outblock() {
                            |res0: List[String] = List(Barb, Bill)
                        }
                    }
                    @codesub() {
                        Rückgabe via for-Ausdruck
                    }
                } {
                    @snippet() {
                        @callblock(reference = "people") {
                            |ppl filter {
                            |  p =>
                            |    val firstname = p._1
                            |    firstname.startsWith("B")
                            |} map (_._1)
                        }
                        @outblock() {
                            |res0: List[String] = List(Barb, Bill)
                        }
                    }
                    @codesub() {
                        Rückgabe via Funktionen höherer Ordnung
                    }
                }
            }

            <!-- ################################################################################## -->

            @slide(title = title) {
                @sourcecode() {
                    |val ppl = List("Anna" -> "Adams", "Adam" -> "Adams", "Barb" -> "Brown", "Bill" -> "Brown")
                }

                @spacer()

                @fragment {
                    <div class="tcenter">
                        <span class="big underline">
                            Welche Personen haben den gleichen Nachnamen ?
                        </span>
                    </div>
                }

                @spacer2()

                @sidebyside((50,50)) {
                    @snippet() {
                        @callblock(reference = "people") {
                            |for {
                            |  p1 <- ppl                 // Gener. #1
                            |  p2 <- ppl filter(_ != p1) // Gener. #2
                            |  if p1._2 == p2._2         // Filter
                            |} yield (p1, p2)
                        }
                        @outblock() {
                            |List(((Anna,Adams),(Adam,Adams))
                            |     ((Adam,Adams),(Anna,Adams))
                            |     ((Barb,Brown),(Bill,Brown))
                            |     ((Bill,Adams),(Barb,Brown)))
                        }
                    }
                    @codesub() {
                        via for-Ausdruck
                    }
                } {
                    @snippet() {
                        @callblock(reference = "people") {
                            |ppl.flatMap { p1 =>
                            |  ppl.filter {
                            |    p2 => p1 != p2
                            |  } filter {
                            |    p2 => p1._2 == p2._2
                            |  } map {
                            |    p2 => (p1, p2)
                            |  }
                            |}
                        }
                        @outblock() {
                            |List(((Anna,Adams),(Adam,Adams))
                            |     ((Adam,Adams),(Anna,Adams))
                            |     ((Barb,Brown),(Bill,Brown))
                            |     ((Bill,Adams),(Barb,Brown)))
                        }
                    }
                    @codesub() {
                        via Funktionen höherer Ordnung
                    }
                }
            }
        }

        <!-- ################################################################################## -->

        @uebung("030") {

            Die Übung ist unter
                <code>/src/main/scala/de/learnscala/uebungen/<em>U320.scala</em></code>
            zu finden.

            @spacer()

            Die dazugehörige Testspezifikation unter
                <code>/src/test/scala/de/learnscala/specs/<var>U320.scala</var></code>.
        }
    }
}