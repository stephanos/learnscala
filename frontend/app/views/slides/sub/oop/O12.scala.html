@defining("Objekte") { implicit topic =>

    @layout.slidedeck(topic) {

        @slidehead() {
            @topic
        } {

        }

        <!--################################################################################## -->

        @slide(title = "static ?") {

            @sidebyside((60,40)) {
                @snippet() {
                    @sourceblock(fragment = false) {
                        |class AccountFactory {
                        |
                        |  static var lastNumber = 0
                        |
                        |  def newAccount(owner: String) = {
                        |    lastNumber += 1
                        |    new Accounts(lastNumber)
                        |  }
                        |}
                    }
                    @outblock(error = true) {
                        |error: ';' expected but 'var' found.
                        |       static var lastNumber = 0
                    }
                }
            } {
                @codenote() {
                    <code>static</code> gibt es in Scala nicht ...
                }
            }
        }


        <object>
            @sourcecode(id = "account") {
                |class Account(val owner: String, val number: Int)
            }
        </object>

        <!--################################################################################## -->

        @defining("Singleton") { title =>

            @slide(title = title) {

                @codesplits((60,40), id="accountfactory", fragment = false){
                    @splitstart(reference = "account") {
                        |object AccountFactory @("{")
                    }{
                        ... aber Objekte.
                    }
                    @codesplit() {
                        |   var lastNumber = 0
                    } {
                        @li{<em>globaler Zustand</em>}
                    }
                    @codesplit() {
                        |   def newAccount(owner: String) = {
                        |       lastNumber += 1
                        |       new Account(owner, lastNumber)
                        |   }
                    } {
                        @li{<em>Factory</em>-Methoden}
                    }
                    @splitend() {
                        |@("}")
                    }(null)
                }

                @spacer()

                @sidebyside((60,40)) {
                    @callcode(reference = "accountfactory") {
                        |val acc = AccountFactory.newAccount("Bob")
                    }
                } {
                }

                @infobox() {
                    <code>object</code> definiert ein Singleton-Objekt:
                    Es existiert <strong>genau eine Instanz</strong>,
                    die beim ersten Zugriff instanziiert wird - Parameter gibt es nicht.
                }
            }

            @slide(title = title, subtitle = "Beispiel") {

                @sidebyside((60,40)) {
                    @sourcecode() {
                        |object MyApplication {
                        |
                        |  def main(args: Array[String]) {
                        |    println("Hello World!")
                        |  }
                        |}
                    }
                } {
                    @codenote() {
                        Singleton <code>MyApplication</code> definiert
                        den Einstiegspunkt <code>main</code> zum Ausführen
                    }
                }
            }
        }

        <!--################################################################################## -->

        @defining("Companion") { title =>

            @slide(title = title) {

                @sidebyside((60,40)) {
                    @sourcecode(id = "account2", fragment = false) {
                        |// Account.scala
                        |class Account private (val owner: String,
                        |                       val number: Int) {
                        |
                        |  def totalCount = Account.lastNumber
                        |}
                    }
                } {
                    @codenote() {
                        Klasse <code>Account</code> hat einen privaten Konstruktor
                    }
                }

                @spacer()

                @sidebyside((60,40)) {
                    @sourcecode(id = "accountobj", reference = "account2") {
                        |// Account.scala
                        |object Account {
                        |
                        |  private var lastNumber = 0
                        |
                        |  def newAccount(owner: String) = {
                        |    lastNumber += 1
                        |    new Account(owner, lastNumber)
                        |  }
                        |}
                    }
                } {
                    @codenote() {
                        Companion Object <code>Account</code> definiert Factory-Methode
                    }
                }

                @spacer()

                @sidebyside((60,40)) {
                    @snippet() {
                        @callblock(reference = "accountobj") {
                            |val acc = Account.newAccount("Bob")
                        }
                        @outblock() {
                            |acc: Account = Account@@536502d
                        }
                        @callblock() {
                            |println(acc.totalCount)
                        }
                        @outblock() {
                            |1
                        }
                    }
                } {
                    @codenote() {
                        Companion Object und Klasse haben gegenseitig privaten Zugriff
                    }
                }

                <!--@infobox() {
                    Das Companion Object einer Klasse muss den selben Namen tragen und in der selben Datei
                    definiert werden, dann hat es privaten Zugriff - und umgekehrt.
                }-->
            }

            <!--################################################################################## -->

            @slide(title = title, subtitle = "Beispiele") {

                @sidebyside((70,30)) {
                    @callcode() {
                        |val bigNumber = BigInt("1234567890")
                    }
                } {
                    @codenote() {
                        erstellt ein <code>BigInt</code> mit dem Wert 1234567890
                    }
                }

                @spacer2()

                @sidebyside((70,30)) {
                    @callcode() {
                        |val countdown = Array(10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
                    }
                } {
                    @codenote() {
                        erstellt ein <code>Array</code> aus den Zahlen von 10 bis 0
                    }
                }

                <!--@infobox() {
                    Für viele Datentypen und -strukturen gibt es gleichnamige Objekte
                    <comment>("Companion Objects")</comment> mit speziellen Factory-Methoden.
                }-->
            }
        }

        <!--################################################################################## -->

        @slide(title = "apply") {

            @sidebyside((60,40)) {
                @sourcecode(id = "apply", reference = "account2", fragment = false) {
                        |object Account {
                        |
                        |  private var lastNumber = 0
                        |
                        |  def apply(owner: String) = {
                        |    lastNumber += 1
                        |    new Account(owner, lastNumber)
                        |  }
                        |}
                }
            } {
                @codenote() {
                    Objekt enthält <code>apply</code>-Methode
                    zum Erstellen einer neuen Instanz von <code>Account</code>
                }
            }

            @spacer()

            @sidebyside((60,40), fragment = true) {
                @snippet() {
                    @callblock(reference = "apply", fragment = false) {
                        val acc = Account("Bob")
                    }
                    @outblock() {
                        |p: Account = Account@@536502d
                    }
                    @callblock() {
                        |val acc = Account()
                    }
                    @outblock() {
                        |error: not enough arguments for method apply
                    }
                }
            } {
                @codenote() {
                    <code>apply</code> wird aufgerufen,
                    wenn keine explizite Methode angegeben wird
                }
            }

            <!--@infobox() {
                Die Methode <code>apply</code> kann implizit durch
                Angabe einer Parameterliste hinter einem Objekt <comment class="nobreak">(Object(arg1, ..., argN))</comment>
                aufgerufen werden - das verkürzt den Code!
            }-->
        }

        <!--################################################################################## -->

        @slide(title = "Predef") {

            @sidebyside((66,33)) {
                @snippet() {
                    @callblock(fragment = false) {
                        |Predef.println("Account was created")
                    }
                    @outblock() {
                        |Account was created
                    }
                    @callblock() {
                        |println("Account was created")
                    }
                    @outblock() {
                        |Account was created
                    }
                }
            } {
                @codenote() {
                    Methode <code>println</code> - Teil des Objekts @apilink("Predef", "Predef$") -
                    kann ohne Objektreferenz verwendet werden
                }
            }

            @spacer2()

            @sidebyside((66,33)) {
                @snippet() {
                    @callblock() {
                        |val accountNumber = -42
                    }
                    @callblock() {
                        |require(accountNumber > 0, "Invalid account number!")
                    }
                    @outblock() {
                        |java.lang.IllegalArgumentException:
                        | requirement failed: Invalid account number
                        |       at scala.Predef$.require(Predef.scala:157)
                    }
                }
            } {
                @codenote() {
                    Methode <code>require</code> wirft <code>IllegalArgumentException</code>
                    falls die Bedingung nicht wahr ist
                }
            }

            <!--@infobox() {
                Das <code>Predef</code>-Objekt wird automatisch für jede Klasse importiert,
                es enthält hilfreiche Befehle, Typen und Werte - kann aber nicht erweitert werden.
            }-->
        }

        <!--################################################################################## -->

        @uebung("000") {
            Die Übung ist unter
                <code>/src/main/scala/de/learnscala/uebungen/<em>U110.scala</em></code>
            zu finden.

            @spacer()

            Die dazugehörige Testspezifikation unter
                <code>/src/test/scala/de/learnscala/specs/<var>S110.scala</var></code>.
        }
    }
}