@slide(title = "Implicits") {
    Implicits
    <!-- (A) conversions to an expected type -->
} {
    <div class="sidebyside">
        <div>
            @snippet() {
                @sourceblock(fragment = false) {
                    |def asSeconds(ms: Long) = ms / 1000
                }
                @outblock() {
                    |asSeconds: (ms: Long)Long
                }
                @callblock() {
                    |asSeconds(1000L)  // Long
                }
                @outblock() {
                    |res0: Long = 1
                }
                @callblock() {
                    |asSeconds(1000)   // Int
                }
                @outblock() {
                    |res0: Long = 1
                }
            }
        </div>
        @codenote() {
            Methode <code>asSeconds</code> erwartet ein Argument vom Typ <code>Long</code> -
            doch trotzdem ist der Aufruf mit <code>Int</code> erfolgreich
        }
    </div>

    <hr/><hr/>

    @sourcecode() {
        |// Predef.scala
        |implicit def int2long(x: Int): Long = x.toLong
    }
    <hr/>
    @fragment {
        <sub>
            <!--Wenn beim Aufruf einer Methode der Typ von Argument und Parameter nicht zusammenpassen,
            sucht Scala nach einer <code>implicit</code>-Definition zur Konvertierung
            ("implicit conversion to an expected type").-->
        </sub>
    }
}


@slide() {
    <!-- (B) conversions of the receiver of a selection -->
} {
    <div class="sidebyside p60_40">
        <div>
            @snippet() {
                @callblock(fragment = false) {
                    |1 -> 'a'
                }
                @outblock() {
                    |res0: (Int, Char) = (1,a)
                }
            }
        </div>
        @codenote() {
            Hm, <br/>
            <code>Int</code> hat keine Methode <code>-></code>
        }
    </div>

    <hr/>

    <div class="sidebyside p60_40">
        <div>
            @snippet() {
                @callblock() {
                    |1 to 10
                }
                @outblock() {
                    |res0: List[Int] = List(1,2,3,4,5,6,7,8,9,10)
                }
            }
        </div>
        @codenote() {
            Hmm, <br/>
            <code>Int</code> hat auch keine Methode <code>to</code>
        }
    </div>

    <hr/>

    <div class="sidebyside p60_40">
        <div>
            @snippet() {
                @callblock() {
                    |"Hello".toList
                }
                @outblock() {
                    |res0: List[Char] = List(H, e, l, l, o)
                }
            }
        </div>
        @codenote() {
            Hmmm, <br/>
            <code>String</code> hat keine Methode <code>toList</code>
        }
    </div>

    <hr/><hr/>

    @sourcecode() {
        |// Predef.scala
        |implicit def augmentString(x: String) = new StringOps(x)
        |implicit def intWrapper   (x: Int)    = new runtime.RichInt(x)
    }
    <hr/>
    @fragment {
        <sub>
            <!--Beim Aufruf einer nicht existierenden Methode sucht Scala nach einer
            <code>implicit</code>-Definition um eine Typ-Konvertierungen durchführen
            - in diesem Fall von <code>String</code> zu <code>StringOps</code> und
            <code>Int</code> zu <code>RichInt</code>
            ("implicit conversions of the receiver of a selection").-->
        </sub>
    }
}

@*@slide() {
    <!-- (C) implicit parameters -->
} {

}*@


@slide() {
    Implicits: Regeln
    <!-- Rules -->
} {
    <div class="indent">
        <ol>
            <li class="fragment">
                <em>Keyword</em>
                <hr/>
                <ul>
                    <li>
                        Nur Methoden mit <code>implicit</code> werden auch als Implicits angesehen.
                    </li>
                </ul>
            </li>
            <li class="fragment">
                <em>Scope</em>
                <hr/>
                <ul>
                    <li>
                        Nur <code>implicits</code> im aktuellen Scope werden verwendet.
                    </li>
                </ul>
            </li>
            <li class="fragment">
                <em>"Immer nur einer"</em>
                <hr/>
                <ul>
                    <li>
                        Es wird stets nur <em>1</em> Implicit gleichzeitig verwendet.
                    </li>
                </ul>
            </li>
            <li class="fragment">
                <em>"Explizit hat Vorrang"</em>
                <hr/>
                <ul>
                    <li>
                        Implicits werden nur bei Typenfehlern herangezogen.
                    </li>
                </ul>
            </li>
            <li class="fragment">
                <em>Eindeutig</em>
                <hr/>
                <ul>
                    <li>
                        Nur wenn es genau ein mögliches Implicit gibt, wird es angewandt.
                    </li>
                </ul>
            </li>
        </ol>
    </div>
}


@slide() {
    <!-- Scope -->
} {
    <div class="sidebyside p60_40">
        @sourcecode(id = "euro_dollar", fragment = false) {
            |case class EUR(v: Float)
            |case class USD(v: Float)
        }
        @empty()
    </div>

    <hr/>

    <!-- directly -->
    <div class="sidebyside p60_40">
        @snippet() {
            @sourceblock(reference = "euro_dollar") {
                |implicit def USD2EUR(x: USD) = EUR(x.v * 0.81f)
            }
            @callblock() {
                |val eur: EUR = USD(5)
            }
            @outblock() {
                |eur: EUR = EUR(4.05)
            }
        }
        @codenote() {
            Implicit wird direkt im Scope definiert
        }
    </div>

    <hr/>

    <!-- import -->
    <div class="sidebyside p60_40">
        @snippet() {
            @sourceblock(reference = "euro_dollar") {
                |object Convert {
                |  implicit def USD2EUR(x: USD) = EUR(x.v * 0.81f)
                |}
            }
            @callblock() {
                |import Convert.USD2EUR
                |val eur: EUR = USD(5)
            }
            @outblock() {
                |eur: EUR = EUR(4.05)
            }
        }
        @codenote() {
            Implicit wird in einem Objekt definiert und importiert
        }
    </div>

    <hr/>

    <!-- companion -->
    <div class="sidebyside p60_40">
        @snippet() {
            @sourceblock(reference = "euro_dollar") {
                |object USD {
                |  implicit def USD2EUR(x: USD) = EUR(x.v * 0.81f)
                |}
            }
            @callblock() {
                |val eur: EUR = USD(5)
            }
            @outblock() {
                |eur: EUR = EUR(4.05)
            }
        }
        @codenote() {
            Implicit wird im Companion Object definiert
        }
    </div>
}


@uebung() {

    Die Übung ist unter
        <code>/src/main/scala/de/learnscala/uebungen/<em>U410.scala</em></code>
    zu finden.

    <hr/>

    Die dazugehörige Testspezifikation unter
        <code>/src/test/scala/de/learnscala/specs/<var>U410.scala</var></code>.
}


@*@slide() {
    <!-- Example: Time (plus View Bounds) -->
} {
    <!-- directly -->
    <div class="sidebyside p60_40">
        @snippet() {
            @sourceblock() {
                |case class Euro(value: Float)
                |case class Dollar(value: Float)
            }
            @sourceblock() {
                |implicit def dollarToEuro(x: Dollar): Euro =
                |   Euro(x.value * 0.81f)
            }
        }
        @empty()
    </div>
}*@