@defining(Content.kontrollstrukturen.label) { implicit topic =>

    @layout.slidedeck(topic) {

        @slidehead() {
            @topic
        } {

        }

        <!-- ################################################################################## -->

        @defining("if else") { title =>

            @slide(title = title) {

                @snippet() {
                    @sourceblock(fragment = false) {
                        |def sufficientFuel(f: Float) =
                        |   if (f >= 50.0) true else false
                    }
                    @outblock() {
                        |sufficientFuel: (f: Float)Boolean
                    }
                }

                @fragment {
                    Methode <code>sufficientFuel</code> hat den Rückgabetyp der Bedingung: <code>Boolean</code>
                }

                @spacer()

                @infobox() {
                    Eine Bedingung hat immer einen Wert.
                }
            }
        }

        <!-- ################################################################################## -->

        @uebung("030")

        <!-- ################################################################################## -->

        @defining("try catch") { title =>

            @slide(title = title) {

                @sidebyside((66,33)) {
                    @snippet() {
                        @sourceblock(fragment = false) {
                            |def getWords(msg: String) =
                            |   try {
                            |       println(msg.split(' '))
                            |   } catch {
                            |       case ex: NullPointerException =>
                            |           println("No message")
                            |       case _ =>
                            |           println("Unexpected internal error")
                            |   } finally {
                            |       // cleanup
                            |   }
                        }
                        @callblock() {
                            |getWords(null)
                        }
                        @outblock() {
                            |No message
                        }
                    }
                } {
                }

                @infobox() {
                    In einem <code>try/catch</code>-Block kommt Pattern Matching zum Einsatz.
                }
            }

            <!-- ################################################################################## -->

            @slide(title = title, subtitle = "throw") {

                @sidebyside((66,33)) {
                    @snippet() {
                        @sourceblock(id = "fuel-exception", fragment = false) {
                            |def sufficientFuel(f: Float) =
                            |  if(f == 0.0)
                            |    throw new RuntimeException("Not enough fuel!")
                        }
                        @callblock() {
                            |sufficientFuel(0)
                        }
                        @outblock() {
                            |java.lang.RuntimeException: Not enough fuel!
                        }
                    }
                } {
                }

                @infobox() {
                    Mit <code>throw</code> wird eine Ausnahme ausgelöst,
                    eine Angabe der möglichen Ausnahmen einer Methode kann/muss nicht spezifiziert werden.
                }
            }
        }

        <!-- ################################################################################## -->

        @uebung("030")

        <!-- ################################################################################## -->

        @slide(title = "while") {

            @sidebyside(gap = 15) {
                @snippet() {
                    @sourceblock(fragment = false) {
                        |def countdown() {
                        |  var i = 10
                        |  while (i >= 0) {
                        |    print(i + " ");
                        |    i -= 1
                        |  }
                        |}
                    }
                    @callblock() {
                        |countdown()
                    }
                    @outblock() {
                        |10 9 8 7 6 5 4 3 2 1 0
                    }
                }
                @codesub2() {
                    Kopfschleife
                }
            } {
                @snippet() {
                    @sourceblock() {
                        |def countdown() {
                        |  var i = 10
                        |  do {
                        |    print(i + " ")
                        |    i -= 1
                        |  } while (i >= 0)
                        |}
                    }
                    @callblock() {
                        |countdown()
                    }
                    @outblock() {
                        |10 9 8 7 6 5 4 3 2 1 0
                    }
                }
                @codesub2() {
                    Fußschleife
                }
            }

            @*@warnbox(hr = false) {
                Klassische Schleifen werden in Scala eher selten eingesetzt;
                man sollte sich stets fragen ob es nicht eine funktionalere Variante gibt.
            }*@
        }

        <!-- ################################################################################## -->

        @slide(title = "for") {

            @sidebyside() {
                @snippet() {
                    @sourceblock() {
                        |def countdown() {
                        |  for (i <- 10 to 0 by -1)
                        |    print(i + " ")
                        |}
                    |}
                    @callblock() {
                        |countdown()
                    }
                    @outblock() {
                        |10 9 8 7 6 5 4 3 2 1 0
                    }
                }
            } {
                @snippet() {
                    @sourceblock() {
                        |def countdown() {
                        |  for (i <- 10 until -1 by -1)
                        |    print(i + " ")
                        |}
                    |}
                    @callblock() {
                        |countdown()
                    }
                    @outblock() {
                        |10 9 8 7 6 5 4 3 2 1 0
                    }
                }
            }
        }

        <!-- ################################################################################## -->

        @uebung("030")

        <!-- ################################################################################## -->

        @defining("match") { title =>

            @slide() {
                <!-- Syntax -->

                @sidebyside((60,40)) {
                    @snippet() {
                        @sourceblock(fragment = false) {
                            |def interpret(msg: String) {
                            |  msg match {
                            |    case "OUT"    => println("The end")
                            |    case "OVER"   => println("Your turn")
                            |    case "MAYDAY" => println("We need help!")
                            |  }
                            |}
                        }
                        @callblock() {
                            |interpret("MAYDAY")
                        }
                        @outblock() {
                            |We need help!
                        }
                    }
                } {
                }

                @spacer()

                @infobox() {
                    Ein Ausdruck kann mittels <code>match</code> gegen verschiedene Alternativen -
                    eingeleitet durch <code>case</code> - "gematched" werden.
                }
            }

            <!-- ################################################################################## -->

            @slide() {
                <!-- MatchError / Wildcard -->

                @sidebyside() {
                    @snippet() {
                        @sourceblock(fragment = false) {
                            |def interpret(msg: String) =
                            |  msg match {
                            |    case "OUT"    => "The end"
                            |    case "OVER"   => "Your turn"
                            |    case "MAYDAY" => "We need help!"
                            |  }
                        }
                        @callblock() {
                            |println(interpret("Ready for take-off"))
                        }
                        @outblock(error = true) {
                            |scala.MatchError: Ready for take-off
                        }
                    }
                } {
                    @snippet() {
                        @sourceblock() {
                            |def interpret(msg: String) =
                            |  msg match {
                            |    case "OUT"    => "The end"
                            |    case "OVER"   => "Your turn"
                            |    case "MAYDAY" => "We need help!"
                            |    case _        => msg
                            |  }
                        }
                        @callblock() {
                            |println(interpret("Ready for take-off"))
                        }
                        @outblock() {
                            |Ready for take-off
                        }
                    }
                }

                @spacer()

                @infobox() {
                    Trifft kein Pattern zu wird eine <code>MatchError</code>-Exception geworfen;
                    mit dem <span class="nobreak">Wildcard-Pattern <code>_</code></span>
                    kann jedoch ein Standardverhalten für diesen Fall definiert werden.
                }
            }

            <!-- ################################################################################## -->

            @slide() {
                <!-- Names -->

                @sidebyside() {
                    @snippet() {
                        @sourceblock(fragment = false) {
                            |def interpret(msg: String) =
                            |  msg match {
                            |    case "OUT"    => "The end"
                            |    case "OVER"   => "Your turn"
                            |    case "MAYDAY" => "We need help!"
                            |    case m        => m.toUpperCase
                            |  }
                        }
                        @callblock() {
                            |println(interpret("Ready for take-off"))
                        }
                        @outblock() {
                            |READY FOR TAKE-OFF
                        }
                    }
                } {
                }

                @spacer()

                @infobox() {
                    Folgt auf <code>case</code> ein Variablenname <comment>(muss mit einem Kleinbuchstaben anfangen)</comment>
                    kann dieser im Ergebnis-Ausdruck (rechts von <code>=></code>) verwendet werden.
                }
            }

        }
    }
}


<!--
e match {
  case pat1 => e1: T1
  case pat2a | ... | pat2n => e2: T2
  ...
  case patn => en: Tn
}

        def days(month: Int, leap: Boolean): Int =
          month match {
            case 2 if leap       => 29 // guarded pattern
            case 2               => 28 // note: order is important here!
            case 4 | 6 | 9 | 11  => 30 // alternative pattern
            case _               => 31 // wildcard pattern
          }
-->