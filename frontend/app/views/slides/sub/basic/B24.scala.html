<!--
    - implicit class
-->
@defining("Implicits I") { implicit topic =>

    @layout.slidedeck(topic) {

        @slidehead() {
            @topic
        } {
            Implizite Typ-Konvertierungen
        }

        <!--################################################################################## -->

        @defining("Einführung") { title =>

            @slide(title = title) {
                @sidebyside() {
                    @snippet() {
                        @sourceblock(fragment = false) {
                            |def asSeconds(ms: Long) = ms / 1000
                        }
                        @outblock() {
                            |asSeconds: (ms: Long)Long
                        }
                        @callblock() {
                            |asSeconds(1000L)  // Long
                        }
                        @outblock() {
                            |res0: Long = 1
                        }
                        @callblock() {
                            |asSeconds(1000)   // Int
                        }
                        @outblock() {
                            |res0: Long = 1
                        }
                    }
                } {
                    @codenote() {
                        Methode <code>asSeconds</code> erwartet ein Argument vom Typ <code>Long</code> -
                        doch trotzdem ist der Aufruf mit <code>Int</code> erfolgreich
                    }
                }

                @spacer()

                @sourcecode() {
                    |// Predef.scala
                    |implicit def int2long(x: Int): Long = x.toLong
                }
                @codesub() {
                    Objekt <code>Predef</code> definiert eine implizierte Konvertierungsmethode
                }

                <!--@infobox() {
                    Wenn beim Aufruf einer Methode der Typ von Argument und Parameter nicht zusammenpassen,
                    sucht Scala nach einer <code>implicit</code>-Definition zur Konvertierung.
                }-->
            }

            <!--################################################################################## -->

            @slide(title = title) {
                @sidebyside((60,40)) {
                    @snippet() {
                        @callblock(fragment = false) {
                            |1 -> 'a'
                        }
                        @outblock() {
                            |res0: (Int, Char) = (1,a)
                        }
                    }
                } {
                    @codenote() {
                        Hm, <br/>
                        <code>Int</code> hat keine Methode <code>-></code>
                    }
                }

                @spacer()

                @sidebyside((60,40)) {
                    @snippet() {
                        @callblock() {
                            |1 to 10
                        }
                        @outblock() {
                            |res0: List[Int] = List(1,2,3,4,5,6,7,8,9,10)
                        }
                    }
                } {
                    @codenote() {
                        Hmm, <br/>
                        <code>Int</code> hat auch keine Methode <code>to</code>
                    }
                }

                @spacer()

                @sidebyside((60,40)) {
                    @snippet() {
                        @callblock() {
                            |"Hello".toList
                        }
                        @outblock() {
                            |res0: List[Char] = List(H, e, l, l, o)
                        }
                    }
                } {
                    @codenote() {
                        Hmmm, <br/>
                        <code>String</code> hat keine Methode <code>toList</code>
                    }
                }

                @spacer()

                @sourcecode() {
                    |// Predef.scala
                    |implicit def augmentString(x: String) = new StringOps(x)
                    |implicit def intWrapper   (x: Int)    = new runtime.RichInt(x)
                }
                @codesub() {
                    <code>Predef</code> definiert implizite Konvertierung
                    von <code>String</code> zu <code>StringOps</code> und
                    <code>Int</code> zu <code>RichInt</code>
                }

                <!--@infobox() {
                    Beim Aufruf einer nicht existierenden Methode sucht Scala nach einer
                    <code>implicit</code>-Definition um eine Typ-Konvertierungen durchführen.
                }-->
            }
        }

        <!--################################################################################## -->

        @defining("Regeln") { title =>

            @defining("Explizit hat Vorrang") { regel =>

                @headslide(title = title, subtitle = regel) {
                    @title: <em>@regel</em>
                } {
                    @infobox() {
                        Implicits werden nur bei Typenfehlern herangezogen.
                    }
                }
            }

            <!--################################################################################## -->

            @defining("Schlüsselwort") { regel =>

                @headslide(title = title, subtitle = regel) {
                    @title<span class="fragment">: <em>@regel</em></span>
                } {

                    @infobox() {
                        Zur impliziten Umwandlung werden nur Methoden verwendet,
                        die mit <code>implicit</code> markiert sind.
                    }
                }
            }

            <!--################################################################################## -->

            @defining("Scope") { regel =>

                @headslide(title = title, subtitle = regel) {
                    @title: <em>@regel</em>
                } {
                    @infobox() {
                        Die Definition muss sichtbar sein, d.h. sich im aktuellen Scope befinden;
                        oder sich im jeweiligen Companion-Objekt befinden.
                    }
                }

                <!--################################################################################## -->

                @slide(title = title, subtitle = regel) {
                    @sidebyside((60,40)) {
                        @sourcecode(id = "euro_dollar", fragment = false) {
                            |case class EUR(v: Float)
                            |case class USD(v: Float)
                        }
                    } {
                    }

                    @spacer()

                    <!-- directly -->
                    @sidebyside((60,40)) {
                        @snippet() {
                            @sourceblock(reference = "euro_dollar") {
                                |implicit def USD2EUR(x: USD) = EUR(x.v * 0.81f)
                            }
                            @callblock() {
                                |val eur: EUR = USD(5)
                            }
                            @outblock() {
                                |eur: EUR = EUR(4.05)
                            }
                        }
                    } {
                        @codenote() {
                            <em>(A)</em> Implicit wird direkt im Scope definiert
                        }
                    }

                    @spacer_half()

                    <!-- import -->
                    @sidebyside((60,40)) {
                        @snippet() {
                            @sourceblock(reference = "euro_dollar") {
                                |object Convert {
                                |  implicit def USD2EUR(x: USD) = EUR(x.v * 0.81f)
                                |}
                            }
                            @callblock() {
                                |import Convert.USD2EUR
                                |val eur: EUR = USD(5)
                            }
                            @outblock() {
                                |eur: EUR = EUR(4.05)
                            }
                        }
                    } {
                        @codenote() {
                            <em>(B)</em> Implicit wird in einem Objekt definiert und importiert
                        }
                    }

                    @spacer_half()

                    <!-- companion -->
                    @sidebyside((60,40)) {
                        @snippet() {
                            @sourceblock(reference = "euro_dollar") {
                                |object USD {
                                |  implicit def USD2EUR(x: USD) = EUR(x.v * 0.81f)
                                |}
                            }
                            @callblock() {
                                |val eur: EUR = USD(5)
                            }
                            @outblock() {
                                |eur: EUR = EUR(4.05)
                            }
                        }
                    } {
                        @codenote() {
                            <em>(C)</em> Implicit wird im Companion Object definiert
                        }
                    }
                }
            }

            <!--################################################################################## -->

            @defining("Eindeutigkeit") { regel =>

                @headslide(title = title, subtitle = regel) {
                    @title: <em>@regel</em>
                } {
                    @infobox() {
                        Die Umwandlung muss eindeutig sein -
                        bei mehreren Methoden wird ein Typfehler gemeldet.
                    }
                }
            }

            <!--################################################################################## -->

            @defining("Immer nur einer") { regel =>

                @headslide(title = title, subtitle = regel) {
                    @title: <em>@regel</em>
                } {
                    @infobox() {
                        Es wird pro Typfehler stets nur maximal eine implizite Umwandelung eingesetzt.
                    }
                }
            }
        }

        <!--################################################################################## -->

        @slide(title = "Anwendungsbeispiel") {

        }

        <!--################################################################################## -->

        @uebung("000") {

            Die Übung ist unter
                <code>/src/main/scala/de/learnscala/uebungen/<em>U410.scala</em></code>
            zu finden.

            @spacer()

            Die dazugehörige Testspezifikation unter
                <code>/src/test/scala/de/learnscala/specs/<var>U410.scala</var></code>.
        }
    }
}