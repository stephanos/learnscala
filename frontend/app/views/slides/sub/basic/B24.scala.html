<!--
    - implicit class
-->
@defining("Implicits I") { implicit topic =>

    @layout.slidedeck(topic) {

        @slidehead() {
            @topic
        } {
            Implizite Typ-Konvertierungen
        }

        <!--################################################################################## -->

        @defining("Einführung") { title =>

            @slide(title = title) {
                @sidebyside() {
                    @snippet() {
                        @sourceblock(fragment = false) {
                            |def asSeconds(ms: Long) = ms / 1000
                        }
                        @outblock() {
                            |asSeconds: (ms: Long)Long
                        }
                        @callblock() {
                            |asSeconds(1000L)  // Long
                        }
                        @outblock() {
                            |res0: Long = 1
                        }
                        @callblock() {
                            |asSeconds(1000)   // Int
                        }
                        @outblock() {
                            |res0: Long = 1
                        }
                    }
                } {
                    @codenote() {
                        Methode <code>asSeconds</code> erwartet ein Argument vom Typ <code>Long</code> -
                        doch trotzdem ist der Aufruf mit <code>Int</code> erfolgreich
                    }
                }

                @spacer2()

                @sourcecode() {
                    |// Predef.scala
                    |implicit def int2long(x: Int): Long = x.toLong
                }
                @codesub() {
                    Objekt <code>Predef</code> definiert implizite Konvertierung von
                    <code>Int</code> zu <code>Long</code>
                }

                <!--@infobox() {
                    Wenn beim Aufruf einer Methode der Typ von Argument und Parameter nicht zusammenpassen,
                    sucht Scala nach einer <code>implicit</code>-Definition zur Konvertierung.
                }-->
            }

            <!--################################################################################## -->

            @slide(title = title) {
                @sidebyside((60,40)) {
                    @snippet() {
                        @callblock(fragment = false) {
                            |1 -> 'a'
                        }
                        @outblock() {
                            |res0: (Int, Char) = (1,a)
                        }
                    }
                } {
                    @codenote() {
                        Hm, <br/>
                        <code>Int</code> hat keine Methode <code>-></code>
                    }
                }

                @spacer()

                @sidebyside((60,40)) {
                    @snippet() {
                        @callblock() {
                            |1 to 10
                        }
                        @outblock() {
                            |res0: List[Int] = List(1,2,3,4,5,6,7,8,9,10)
                        }
                    }
                } {
                    @codenote() {
                        Hmm, <br/>
                        <code>Int</code> hat auch keine Methode <code>to</code>
                    }
                }

                @spacer()

                @sidebyside((60,40)) {
                    @snippet() {
                        @callblock() {
                            |(-5).signum
                        }
                        @outblock() {
                            |res0: Int = -1
                        }
                    }
                } {
                    @codenote() {
                        Hmmm, <br/>
                        <code>Int</code> hat ebenso keine Methode <code>signum</code>
                    }
                }

                @spacer2()

                @sourcecode() {
                    |// Predef.scala
                    |implicit def intWrapper   (x: Int)    = new runtime.RichInt(x)
                }
                @codesub() {
                    Objekt <code>Predef</code> definiert implizite Konvertierung von
                    <code>Int</code> zu <code>RichInt</code>
                }

                <!--@infobox() {
                    Beim Aufruf einer nicht existierenden Methode sucht Scala nach einer
                    <code>implicit</code>-Definition um eine Typ-Konvertierungen durchführen.
                }-->
            }
        }

        <!--################################################################################## -->

        @defining("Regel") { title =>

            @defining("Explizit hat Vorrang") { regel =>

                @headslide(title = title, subtitle = regel) {
                    @title: <em>@regel</em>
                } {
                    @sidebyside((66,33)) {
                        @snippet() {
                            @sourceblock(id = "euro_dollar") {
                                |class EUR(val v: Float)
                                |class USD(val v: Float)
                            }
                        }
                    } {
                    }

                    @spacer()

                    @sidebyside((66,33)) {
                        @snippet() {
                            @callblock(reference = "euro_dollar") {
                                |implicit def USD2EUR(x: USD) = new EUR(x.v * 0.8f)
                            }
                            @outblock() {
                                |USD2EUR: (x: USD)EUR
                            }
                        }
                    } {
                        @codenote() {

                        }
                    }

                    @spacer()

                    @sidebyside((66,33)) {
                       @snippet() {
                           @callblock(reference = "euro_dollar") {
                               |implicit def USD2EUR(x: USD) = new EUR(x.v * 0.8f)
                           }
                           @outblock() {
                               |USD2EUR: (x: USD)EUR
                           }
                       }
                    } {
                       @codenote() {

                       }
                    }

                    @spacer_half()

                    @infobox() {
                        Implicits werden nur bei Typenfehlern herangezogen.
                    }
                }
            }

            <!--################################################################################## -->

            @defining("Schlüsselwort") { regel =>

                @headslide(title = title, subtitle = regel) {
                    @title<span class="fragment">: <em>@regel</em></span>
                } {
                    @sidebyside((66,33)) {
                        @snippet() {
                            @sourceblock(id = "euro_dollar") {
                                |class EUR(val v: Float)
                                |class USD(val v: Float)
                            }
                        }
                    } {
                    }

                    @spacer()

                    @sidebyside((66,33)) {
                        @snippet() {
                            @callblock(reference = "euro_dollar") {
                                |def USD2EUR(x: USD) = new EUR(x.v * 0.8f)
                                |val eur: EUR = new USD(5)
                            }
                            @outblock(error = true) {
                                |error   : type mismatch
                                |found   : USD
                                |required: EUR
                            }
                        }
                    } {
                        @codenote() {
                            Methode <var>ohne</var> <code>implicit</code>
                            wird vom Compiler nicht verwendet
                        }
                    }

                    @spacer_half()

                    @sidebyside((66,33)) {
                        @snippet() {
                            @callblock(reference = "euro_dollar") {
                                |implicit def USD2EUR(x: USD) = EUR(x.v * 0.8f)
                                |val eur: EUR = new USD(5)
                            }
                            @outblock() {
                                |eur: EUR = EUR@@39db0ef7
                            }
                        }
                    } {
                        @codenote() {
                            Methode <em>mit</em> <code>implicit</code>
                            führt zur Typkonvertierung
                        }
                    }

                    @spacer_half()

                    @infobox() {
                        Zur impliziten Umwandlung werden nur Methoden verwendet,
                        die mit <code>implicit</code> markiert sind.
                    }
                }
            }

            <!--################################################################################## -->

            @defining("Scope") { regel =>

                @headslide(title = title, subtitle = regel) {
                    @title: <em>@regel</em>
                } {
                    @sidebyside((66,33)) {
                        @sourcecode(id = "euro_dollar", fragment = false) {
                            |class EUR(val v: Float); class USD(val v: Float)
                        }
                    } {
                    }

                    @spacer()

                    @sidebyside((66,33)) {
                        @snippet() {
                            @sourceblock(reference = "euro_dollar") {
                                |implicit def USD2EUR(x: USD) = new EUR(x.v * 0.8f)
                            }
                            @callblock() {
                                |val eur: EUR = new USD(5)
                            }
                        }
                    } {
                        @codenote() {
                            <em>(A)</em> Implicit wird direkt im Scope definiert
                        }
                    }

                    @spacer_half()

                    @sidebyside((66,33)) {
                        @snippet() {
                            @sourceblock(reference = "euro_dollar") {
                                |object Convert {
                                |  implicit def USD2EUR(x: USD) = new EUR(x.v * 0.8f)
                                |}
                            }
                            @callblock() {
                                |import Convert.USD2EUR
                                |val eur: EUR = new USD(5)
                            }
                        }
                    } {
                        @codenote() {
                            <em>(B)</em> Implicit wird in einem Objekt definiert und importiert
                        }
                    }

                    @spacer_half()

                    <!-- companion -->
                    @sidebyside((66,33)) {
                        @snippet() {
                            @sourceblock(reference = "euro_dollar") {
                                |object USD {
                                |  implicit def USD2EUR(x: USD) = new EUR(x.v * 0.8f)
                                |}
                            }
                            @callblock() {
                                |val eur: EUR = new USD(5)
                            }
                        }
                    } {
                        @codenote() {
                            <em>(C)</em> Implicit wird im Companion Object definiert
                        }
                    }

                    @infobox() {
                        Die Definition muss sich im aktuellen Scope befinden; oder im jeweiligen Companion-Objekt.
                    }
                }
            }

            <!--################################################################################## -->

            @defining("Eindeutigkeit") { regel =>

                @headslide(title = title, subtitle = regel) {
                    @title: <em>@regel</em>
                } {
                    @infobox() {
                        Die Umwandlung muss eindeutig sein -
                        bei mehreren Methoden wird ein Typfehler gemeldet.
                    }
                }
            }

            <!--################################################################################## -->

            @defining("Immer nur eine") { regel =>

                @headslide(title = title, subtitle = regel) {
                    @title: <em>@regel</em>
                } {

                    @sidebyside((71,29)) {
                        @sourcecode(id = "euro_dollar_pound") {
                            |class USD(val v: Float)  // A
                            |class EUR(val v: Float)  // B
                            |class GBP(val v: Float)  // C
                        }
                    } {
                        @codenote() {
                        }
                    }

                    @spacer()

                    @sidebyside((71,29)) {
                        @sourcecode(id = "euro_dollar_pound_implicit", reference = "euro_dollar_pound") {
                            |implicit def USD2EUR(x: USD) = new EUR(x.v * 0.8f) // A -> B
                            |implicit def EUR2GBP(x: EUR) = new GBP(x.v * 0.8f) // B -> C
                        }
                    } {
                        @codenote() {

                        }
                    }

                    @spacer()

                    @sidebyside((71,29)) {
                        @snippet() {
                            @callblock(reference = "euro_dollar_pound_implicit") {
                                |val eur: GBP = new USD(5)  // A -> C ?
                            }
                            @outblock(error = true) {
                                |error   : type mismatch;
                                |found   : USD
                                |required: GBP
                            }
                        }
                    } {
                        @codenote() {
                            Compiler kann <code>USD</code> nicht auf <code>GBP</code> mittels
                            Zwischenschritt <code>EUR</code> umwandeln
                        }
                    }

                    @spacer_half()

                    @infobox() {
                        Es wird pro Typfehler stets nur maximal eine implizite Umwandelung eingesetzt.
                    }
                }
            }
        }

        <!--################################################################################## -->

        @slide(title = "Anwendungsbeispiel") {

            <!--
                - https://gist.github.com/1162307
                - http://www.derekwyatt.org/2012/03/12/adding-squared-to-scala-numbers-with-implicts-and-type-classes/
            -->
        }

        <!--################################################################################## -->

        @uebung("000") {

            Die Übung ist unter
                <code>/src/main/scala/de/learnscala/uebungen/<em>U410.scala</em></code>
            zu finden.

            @spacer()

            Die dazugehörige Testspezifikation unter
                <code>/src/test/scala/de/learnscala/specs/<var>U410.scala</var></code>.
        }
    }
}