@defining("Kontrollstrukturen") { implicit topic =>

    @layout.slidedeck(topic) {

        @slidehead() {
            @topic
        } {

        }

        <!--################################################################################## -->

        @slide() {

            @sidebyside() {
                @snippet() {
                    @sourceblock(fragment = false) {
                        |def sufficientFuel(f: Float) =
                        |   if (f >= 50.0) true else false
                    }
                    @outblock() {
                        |sufficientFuel: (f: Float)Boolean
                    }
                }
            } {
                @fragment {
                    Methode <code>sufficientFuel</code> hat den Rückgabetyp der Bedingung: <code>Boolean</code>
                }
            }

            @spacer()

            @infobox() {
                Eine Bedingung hat immer einen Wert.
            }
        }

        <!--################################################################################## -->

        @slide() {

            @sidebyside((66,33)) {
                @snippet() {
                    @sourceblock(fragment = false) {
                        |def almostThere(x0: Int, y0: Int, x: Int, y: Int) = {
                        |   val distance = {
                        |       val dx = x - x0
                        |       val dy = y - y0
                        |       Math.sqrt(dx * dx + dy * dy)
                        |   }
                        |   distance < 20
                        |}
                    }
                    @outblock() {
                        |almostThere: (x0: Int, y0: Int, x: Int, y: Int)Boolean
                    }
                }
            } {
                @fragment {
                    Variable <code>distance</code> hat den Typ der <code>sqrt</code>-Methode: <code>Double</code>
                }
            }

            @spacer()

            @infobox() {
                Ein Block hat immer einen Wert - und zwar den Wert des letzten Ausdrucks
            }
        }

        <!--################################################################################## -->

        @uebung("000") {

            Die Übung ist unter
                <code>/src/main/scala/de/learnscala/uebungen/<em>U030.scala</em></code>
            zu finden.

            @spacer()

            Die dazugehörige Testspezifikation unter
                <code>/src/test/scala/de/learnscala/specs/<var>U030.scala</var></code>.
        }

        <!--################################################################################## -->

        @slide() {
            <!-- Catch -->

            @sidebyside((66,33)) {
                @snippet() {
                    @sourceblock(fragment = false) {
                        |def getWords(msg: String) =
                        |   try {
                        |       println(msg.split(' '))
                        |   } catch {
                        |       case ex: NullPointerException =>
                        |           println("No message")
                        |       case _ =>
                        |           println("Unexpected internal error")
                        |   } finally {
                        |       // cleanup
                        |   }
                    }
                    @callblock() {
                        |getWords(null)
                    }
                    @outblock() {
                        |No message
                    }
                }
            } {
            }

            @infobox() {
                In einem <code>try/catch</code>-Block kommt Pattern Matching zum Einsatz.
            }
        }

        <!--################################################################################## -->

        @slide() {
            <!-- Throw -->

            @sidebyside((66,33)) {
                @snippet() {
                    @sourceblock(id = "fuel-exception", fragment = false) {
                        |def sufficientFuel(f: Float) =
                        |  if(f == 0.0)
                        |    throw new RuntimeException("Not enough fuel!")
                    }
                    @callblock() {
                        |sufficientFuel(0)
                    }
                    @outblock() {
                        |java.lang.RuntimeException: Not enough fuel!
                    }
                }
            } {
            }

            @infobox() {
                Mit <code>throw</code> wird eine Ausnahme ausgelöst,
                eine Angabe der möglichen Ausnahmen einer Methode kann/muss nicht spezifiziert werden.
            }
        }

        <!--################################################################################## -->

        @uebung("000") {

            Die Übung ist unter
                <code>/src/main/scala/de/learnscala/uebungen/<em>U060.scala</em></code>
            zu finden.

            @spacer()

            Die dazugehörige Testspezifikation unter
                <code>/src/test/scala/de/learnscala/specs/<var>U060.scala</var></code>.
        }

        @slide(title = "Schleifen") {

            @sidebyside() {
                @snippet() {
                    @sourceblock(fragment = false) {
                        |def countdown() {
                        |  var i = 10
                        |  while (i >= 0) {
                        |    print(i + " ");
                        |    i -= 1
                        |  }
                        |}
                    }
                    @callblock() {
                        |countdown()
                    }
                    @outblock() {
                        |10 9 8 7 6 5 4 3 2 1 0
                    }
                }
            } {
                @snippet() {
                    @sourceblock() {
                        |def countdown() {
                        |  var i = 10
                        |  do {
                        |    print(i + " ")
                        |    i -= 1
                        |  } while (i >= 0)
                        |}
                    }
                    @callblock() {
                        |countdown()
                    }
                    @outblock() {
                        |10 9 8 7 6 5 4 3 2 1 0
                    }
                }
            }

            @spacer()

            @sidebyside() {
                @snippet() {
                    @sourceblock() {
                        |def countdown() {
                        |  for (i <- 10 to 0 by -1)
                        |    print(i + " ")
                        |}
                    |}
                    @callblock() {
                        |countdown()
                    }
                    @outblock() {
                        |10 9 8 7 6 5 4 3 2 1 0
                    }
                }
            } {
                @snippet() {
                    @sourceblock() {
                        |def countdown() {
                        |  for (i <- 10 until -1 by -1)
                        |    print(i + " ")
                        |}
                    |}
                    @callblock() {
                        |countdown()
                    }
                    @outblock() {
                        |10 9 8 7 6 5 4 3 2 1 0
                    }
                }
            }

            @spacer_half()

            @warnbox(hr = false) {
                Klassische Schleifen werden in Scala eher selten eingesetzt;
                man sollte sich stets fragen ob es nicht eine funktionalere Variante gibt.
            }
        }

        <!--################################################################################## -->

        @uebung("000") {

            Die Übung ist unter
                <code>/src/main/scala/de/learnscala/uebungen/<em>U040.scala</em></code>
            zu finden.

            @spacer()

            Die dazugehörige Testspezifikation unter
                <code>/src/test/scala/de/learnscala/specs/<var>U040.scala</var></code>.
        }
    }
}