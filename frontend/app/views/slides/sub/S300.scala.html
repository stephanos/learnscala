@slide(title = "Collections") {
} {
    <div class="sidebyside">
        @snippet() {
            @callblock(fragment = false, id = "nums") {
                |val nums = List(1, 2, 3)
            }
            @outblock() {
                |nums: List[Int] = List(1, 2, 3)
            }
            @callblock() {
                |nums map { (x: Int) => x + 1 }
            }
            @outblock() {
                |res0: List[Int] = List(2, 3, 4)
            }
        }
        <div>
            <div class="indent">
                <ul>
                    <li class="fragment">
                        Funktion "erhöhe Wert um 1" wird auf jedes Element angewendet; Resultat ist eine neue Liste
                    </li>
                    <li class="fragment">
                        Aufruf der Methode <code>map</code> mit einem <em>Funktionsliteral</em> (anonyme Funktion) als Argument
                    </li>
                    <li class="fragment">
                        Syntax des Funktionsliterals ähnlich der einer Methode:
                        Parameterliste <code>(x: Int)</code> und Körper <code>x + 1</code> getrennt durch <code>=></code>
                    </li>
                    <li class="fragment">
                        übliche Schreibweise: ohne Punkt und mit geschweiften Klammern
                    </li>
                </ul>
            </div>
        </div>
    </div>
}


@slide() {
} {
    <div class="sidebyside">
        @snippet() {
            @callblock(reference = "nums", fragment = false) {
                |nums filter { (x: Int) => x < 3 }
            }
            @outblock() {
                |res0: List[Int] = List(1, 2)
            }
        }
        <div>
            <div class="indent">
                <ul>
                    <li class="fragment">
                        Funktion "ist x kleiner als 3" wird auf jedes Element angewendet;
                        ist das Ergebnis <code>true</code> wird es ins Resultat übernommen
                    </li>
                    <li class="fragment">
                        <code>map</code> und <code>filter</code> sind <em>Funktionen höherer Ordnung</em>
                        ("higher-order functions"): Argument oder Rückgabewert sind wiederum Funktion
                    </li>
                    <li class="fragment">
                        Eigenschaften einer Funktion:
                        <hr/>
                        <ul>
                            <li class="fragment">
                                frei von Seiteneffekten
                            </li>
                            <li class="fragment">
                                hat ein Ergebnis (nicht <code>Unit</code>)
                            </li>
                            <li class="fragment">
                                gleiches Ergebnis für gleiche Argumente
                            </li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </div>
}


@slide() {
    <!-- Funktionsliteral: ohne Typ -->
} {
    <div class="sidebyside">
        @snippet() {
            @callblock(reference = "nums", fragment = false) {
                |nums map { x => x + 1 }
            }
            @outblock() {
                |res0: List[Int] = List(2, 3, 4)
            }
        }
        <div>
            <div class="indent">
                <ul>
                    <li class="fragment">
                        Typ von <code>x</code> kann weggelassen werden
                    </li>
                    <li class="fragment">
                        abgeleitet vom Typ-Parameter der Liste (<code>Int</code>)
                        und der Signatur der Methode <code>map</code>
                    </li>
                </ul>
            </div>
        </div>
    </div>

    <hr/><hr/>

    <div class="sidebyside">
        @sourcecode() {
            |trait Traversable[A] {
            |  def map[B](f: (A) => B): Traversable[B]
            |}
        }
        <div>
            <div class="indent">
                <ul>
                    <li class="fragment">
                        <code>map</code> transformiert die Elemente vom Typ <code>A</code>
                        in eine neue Instanz von <code>Traversable</code> vom Typ <code>B</code>
                    </li>
                </ul>
            </div>
        </div>
    </div>
}


@slide() {
    <!-- Funktionsliteral: ohne Parameterliste -->
} {
    <div class="sidebyside">
        @snippet() {
            @callblock(reference = "nums", fragment = false) {
                |nums filter { _ < 3 }
            }
            @outblock() {
                |res0: List[Int] = List(1, 2)
            }
            @callblock() {
                |nums filter { _ > 0 && _ < 3 }
            }
            @outblock(error = true) {
                |error: wrong number of parameters;
                |       expected = 1
            }
        }
        <div>
            <div class="indent">
                <ul>
                    <li class="fragment">
                        Parameterliste kann weggelassen werden;
                        mit <code>_</code> kann jeder Parameter einmal referenziert werden
                    </li>
                </ul>
            </div>
        </div>
    </div>

    <hr/><hr/>

    <div class="sidebyside">
        @snippet() {
            @callblock(reference = "nums") {
                |nums sortWith { (x, y) => x > y }
            }
            @outblock() {
                |res0: List[Int] = List(3, 2, 1)
            }
            @callblock() {
                |numbers sortWith { _ > _ }
            }
            @outblock() {
                |res1: List[Int] = List(3, 2, 1)
            }
        }
        <div>
            <div class="indent">
                <ul>
                    <li class="fragment">
                        Funktion "ist x größer als y" wird auf jedes Element angewendet
                    </li>
                    <li class="fragment">
                        der erste <code>_</code> repäsentiert den ersten Parameter (x),
                        der zweite <code>_</code> den zweiten Parameter (y)
                    </li>
                </ul>
            </div>
        </div>
    </div>
}


@quiz() {
    @sourcecode(id = "list123", fragment = false) {
        |val l = List(1, 2, 3)
    }

    <hr/><hr/>

    <div class="sidebyside">
        <div>
            <div class="sidebyside p10_90">
                <span>(1)</span>
                @snippet() {
                    @callblock(reference = "list123", fragment = false) {
                        |val r = l map { (x: Int) => x * 2 }
                    }
                    @outblock() {
                        |r: List[Int] = List(2, 4, 6)
                    }
                }
            </div>
        </div>
        <div>
            <div class="sidebyside p10_90">
                <span>(2)</span>
                @snippet() {
                    @callblock(reference = "list123", fragment = false) {
                        |val r = l filter ( _ / 2)
                    }
                    @outblock(error = true) {
                        |error: type mismatch;
                        |found: Int; required: Boolean
                    }
                }
            </div>
        </div>
    </div>

    <hr/>

    <div class="sidebyside">
        <div>
            <div class="sidebyside p10_90">
                <span>(3)</span>
                @snippet() {
                    @callblock(reference = "list123", fragment = false) {
                        |val r = l map ( _ / 2.0)
                    }
                    @outblock() {
                        |r: List[Double] = List(0.5, 1.0, 1.5)
                    }
                }
            </div>
        </div>
        <div>
            <div class="sidebyside p10_90">
                <span>(4)</span>
                @snippet() {
                    @callblock(reference = "list123", fragment = false) {
                        |val r = l map print
                    }
                    @outblock() {
                        |1 2 3r: List[Unit] = List((), (), ())
                    }
                }
            </div>
        </div>
    </div>

    <hr/>

    <div class="sidebyside">
        <div>
            <div class="sidebyside p10_90">
                <span>(5)</span>
                @snippet() {
                    @callblock(reference = "list123", fragment = false) {
                        |val r = l map ((i: Long) => _ - 1)
                    }
                    @outblock(error = true) {
                        |error: missing parameter type
                    }
                }
            </div>
        </div>
        <div>
            <div class="sidebyside p10_90">
                <span>(6)</span>
                @snippet() {
                    @callblock(reference = "list123", fragment = false) {
                        |val r = l map ((i: Long) => i - 1)
                    }
                    @outblock(error = true) {
                        |error: type mismatch;
                        |found: Long => Long; required: Int => ?
                    }
                }
            </div>
        </div>
    </div>

    <hr/>

    <div class="sidebyside">
        <div>
            <div class="sidebyside p10_90">
                <span>(7)</span>
                @snippet() {
                    @callblock(reference = "list123", fragment = false) {
                        |val r = l filter { _ * 2 > 2 }
                    }
                    @outblock() {
                        |r: List[Int] = List(2, 3)
                    }
                }
            </div>
        </div>
        <div>
            <div class="sidebyside p10_90">
                <span>(8)</span>
                @snippet() {
                    @callblock(reference = "list123", fragment = false) {
                        |val r = l map (math.pow(_, 2))
                    }
                    @outblock() {
                        |r: List[Double] = List(1.0, 4.0, 9.0)
                    }
                }
            </div>
        </div>
    </div>
}