@defining("Aktoren") { implicit topic =>

    @layout.slidedeck(topic) {

        @slidehead() {
            @topic
        } {
            Parallele Programmierung
        }

        <!-- ################################################################################## -->

        @slide() {

        }
    }
}

@*
<!--
@headslide(title = "Akka") {
    Akka
} {
    <div class="indent">
        <ul>
            <li>
                eventbasiertes Middleware-Framework
            </li>
            <li class="fragment">
                mittlerweile Teil vom <var>Typesafe Stack</var>
            </li>
            <li class="fragment">
                <em>Ziel:</em> hohe Performanz und Zuverlässigkeit
            </li>
            <li class="fragment">
                höhrere Abstraktionsebene als Threads: <em>Aktoren</em>
            </li>
            <li class="fragment">
                Senden und Empfangen von Nachrichten
            </li>
            <li class="fragment">
                Schnittstellen für Scala und Java
            </li>
        </ul>
    </div>
}

@headslide() {
    Akka
} {
    @snippet() {
        @sourceblock(fragment = false) {
            |// define message
            |case class Greeting(who: String)
            |
            |// define actor
            |class GreetingActor extends Actor with ActorLogging {
            |  def receive = {
            |    case Greeting(who) => log.info("Hello " + who)
            |  }
            |}
            |
            |// initialize actor system
            |val system = ActorSystem("MySystem")
            |
            |// get an actor of type 'GreetingActor'
            |val greeter = system.actorOf(Props[GreetingActor], name = "greeter")
            |
            |// send message to actor
            |greeter ! Greeting("John")
        }
    }
}
-->
*@
