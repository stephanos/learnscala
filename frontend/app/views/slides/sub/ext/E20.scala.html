<!--
    TODO
        - pattern matching
        - NodeSeq.empty
        - namespaces
-->

@implicitSlide = @{ Content.xml }

@defining(implicitSlide.label) { implicit topic =>

    @layout.slidedeck(topic) {

        @slidehead() {
            @topic
        }()

        <!-- ################################################################################## -->

        @defining("Erstellen") { title =>

            @defining("Literale") { subtitle =>

                @slide(title = title, subtitle = subtitle, subsubtitle = "Elem") {

                    @snippet() {
                        @sourceblock() {
                            |val xml =
                            |  &lt;html&gt;
                            |    &lt;head&gt;
                            |      &lt;title&gt;Homepage&lt;/title&gt;
                            |    &lt;/head&gt;
                            |    &lt;body&gt;
                            |      Welcome!
                            |    &lt;/body&gt;
                            |  &lt;/html&gt;
                        }
                        @outblock() {
                            |xml: scala.xml.Elem =
                            |  &lt;html&gt;
                            |    &lt;head&gt;
                            |      &lt;title&gt;Homepage&lt;/title&gt;
                            |    &lt;/head&gt;
                            |    &lt;body&gt;
                            |      Welcome!
                            |    &lt;/body&gt;
                            |  &lt;/html&gt;
                        }
                    }
                    @codesub2() {
                        <code>scala.xml.Elem</code> beschreibt ein allgemeines XML-Element
                    }
                }

                <!-- ################################################################################## -->

                @slide(title = title, subtitle = subtitle, subsubtitle = "NodeSeq") {

                    @snippet() {
                        @sourceblock() {
                            |val xml =
                            |   &lt;li&gt;Milk&lt;/li&gt; &lt;li&gt;Butter&lt;/li&gt; &lt;li&gt;Honey&lt;/li&gt;
                        }
                        @outblock() {
                            |xml: scala.xml.NodeSeq =
                            |   &lt;li&gt;Milk&lt;/li&gt; &lt;li&gt;Butter&lt;/li&gt; &lt;li&gt;Honey&lt;/li&gt;
                        }
                    }
                    @codesub2() {
                        Liste aus XML-Elementen ist vom Typ <code>scala.xml.NodeSeq</code>
                    }
                }
            }

            <!-- ################################################################################## -->

            @slide(title = title, subtitle = "Literale", subsubtitle = "Dynamisch") {
                @snippet() {
                    @sourceblock() {
                        |def xml(name: String) =
                        |  &lt;h1&gt; Welcome {name}! &lt;/h1&gt;
                    }
                    @callblock() {
                        |xml("Paul")
                    }
                    @outblock() {
                        |res0: scala.xml.Elem =
                        |  &lt;h1&gt; Welcome Paul! &lt;/h1&gt;
                    }
                }
                @codesub2() {
                    dynamische Blöcke mit Scala-Code werden von <code>@("{")</code> und <code>@("}")</code> umschlossen
                }

                @spacer2()

                @snippet() {
                    @callblock() {
                        |val xml =
                        |  &lt;h1&gt; My favourite numbers are {{7, 42, 101}} &lt;/h1&gt;
                    }
                    @outblock() {
                        |xml: scala.xml.Elem =
                        |  &lt;h1&gt; My favourite numbers are {7, 42, 101} &lt;/h1&gt;
                    }
                }
                @codesub2() {
                    für das Zeichen <code>@("{")</code> bzw. <code>@("}")</code> muss es doppelt angegeben werden:
                    <code>@("{{")</code> bzw. <code>@("}}")</code>
                }
            }

            <!-- ################################################################################## -->

            @slide(title = title, subtitle = "Literale", subsubtitle = "Dynamisch II") {

                @snippet() {
                    @*@sourceblock() {
                        |&lt;h1&gt; { "Welcome & Goodbye" } &lt;/h1&gt;
                    }
                    @outblock() {
                        |res0: scala.xml.Elem =
                        |  &lt;h1&gt; Welcome @("&amp;") Goodbye  &lt;/h1&gt;
                    }*@
                    @sourceblock() {
                        |&lt;h1&gt; { "<<< Welcome >>>" } &lt;/h1&gt;
                    }
                    @outblock() {
                        |res1: scala.xml.Elem =
                        |  &lt;h1&gt; @("&lt;&lt;&lt;") Welcome @("&gt;&gt;&gt;") &lt;/h1&gt;
                    }
                }
                @codesub2() {
                    XML-Zeichen wie <code>&amp;</code>, <code>&lt;</code> und <code>&gt;</code>
                    werden in entsprechende Escape-Sequenz konvertiert
                }

                @spacer()

                @snippet() {
                    @callblock() {
                        |val items = List(1, 2, 3)
                        |val xml = &lt;ul&gt; { for (i &lt;- items) yield &lt;li&gt;{i}&lt;/li&gt; } &lt;/ul &gt;
                    }
                    @outblock() {
                        |xml: scala.xml.Elem =
                        |  &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;
                    }
                }
                @codesub2() {
                    Blöcke können wiederum XML-Literale enthalten
                }

                @spacer()

                @snippet() {
                    @sourceblock() {
                        |&lt;number&gt;1&lt;/number&gt; ++ &lt;number&gt;2&lt;/number&gt;
                    }
                    @outblock() {
                        |res0: scala.xml.NodeSeq =
                        |  NodeSeq(&lt;number&gt;1&lt;/number&gt;, &lt;number&gt;2&lt;/number&gt;)
                    }
                }
                @codesub2() {
                    <code>++</code> verbindet zwei XML-Elemente zu einem
                }
            }

            <!-- ################################################################################## -->

            @slide(title = title, subtitle = "Literale", subsubtitle = "Attribute") {
                @snippet() {
                    @callblock() {
                        |val xml = &lt;person male="true"&gt; Paul &lt;/person&gt;
                    }
                    @outblock() {
                        |xml: scala.xml.Elem = &lt;person male="true"&gt; Paul &lt;/person&gt;
                    }
                }
                @codesub2() {
                    XML-Elemente können mit Attributen versehen werden
                }

                @spacer_half()

                @snippet() {
                    @callblock() {
                        |def xml(name: String, isMale: Boolean) =
                        |  &lt;person male={isMale}&gt; { name } &lt;/person&gt;
                        |
                        |xml("Paul", true)
                    }
                    @outblock(error = true) {
                        |error: overloaded method constructor
                        |  UnprefixedAttribute with alternatives: ...
                    }
                }
                @codesub2() {
                    Attribut-Block vom Typ <code>Boolean</code> ist @underline("nicht") erlaubt
                }

                @spacer_half()

                @snippet() {
                    @callblock() {
                        |def xml(name: String, isMale: Boolean) =
                        |  &lt;person male={isMale.toString}&gt; { name } &lt;/person&gt;
                        |
                        |xml("Paul", true)
                    }
                    @outblock() {
                        |res0: scala.xml.Elem = &lt;person male="true"&gt; Paul &lt;/person&gt;
                    }
                }
                @codesub2() {
                    Attribut-Block vom Typ <code>String</code> ist erlaubt
                }
            }

            <!-- ################################################################################## -->

            @*@slide(title = title, subtitle = "Manuell") {
                TODO
                <!--http://scalatutorial.de/topic176.html#xmlErzeugen-->
            }*@

            <!-- ################################################################################## -->

            @slide(title = title, subtitle = "Anwendungsbeispiel") {
                @sidebyside() {
                    @snippet(id = "books_out") {
                        @sourceblock() {
                            |case class Book ( title: String,
                            |                  pages: Int, year: Int,
                            |                  available: Boolean ) {
                            |  def toXML =
                            |    &lt;book available={available toString}&gt;
                            |      &lt;title&gt; {title} &lt;/title&gt;
                            |      &lt;pages&gt; {pages} &lt;/pages&gt;
                            |      &lt;year&gt;  {year}  &lt;/year&gt;
                            |    &lt;/book&gt;
                            |}
                        }
                    }
                } {
                    @snippet() {
                        @callblock(reference = "books_out") {
                            |val books = List(
                            |  Book("Programming in Scala",
                            |       883, 2008, true),
                            |  Book("Scala for the Impatient",
                            |       623, 2012, false)
                            |)
                            |
                            |for ( book <- books )
                            |    println book.toXML
                        }
                        @outblock() {
                            |&lt;book available="true"&gt;
                            | &lt;title&gt;Programming in Scala&lt;/title&gt;
                            | &lt;pages&gt;883&lt;/pages&gt;
                            | &lt;year&gt;2008&lt;/year&gt;
                            |&lt;/book&gt;
                            |&lt;book available="false"&gt;
                            | &lt;title&gt;Scala for the Impatient&lt;/title&gt;
                            | &lt;pages&gt;623&lt;/pages&gt;
                            | &lt;year&gt;2012&lt;/year&gt;
                            |&lt;/book&gt;
                        }
                    }
                }
            }
        }

        <!-- ################################################################################## -->

        @slide(title = "Typenhierarchie") {
            @sidebyside() {
                @Images.xmlHierarchy()
            } {
                @spacer()
                @snippet() {
                    @sourceblock() {
                        |import xml._
                        |
                        |&lt;html lang="en"&gt;              // Elem
                        |                              // + Metadata
                        |  &lt;head&gt;
                        |    &lt;title&gt;
                        |      Programming in Scala    // Text
                        |    &lt;/title&gt;
                        |  &lt;/head&gt;
                        |
                        |  &lt;body&gt;
                        |    &lt;!-- Javascript --&gt;       // Comment
                        |    &lt;script&gt; {
                        |     PCData("alert('Hello')") // PCData
                        |    } &lt;/script&gt;
                        |  &lt;/body&gt;
                        |
                        |&lt;/html&gt;
                    }
                }
            }

            <!--@spacer()
            @codenote() {
                Jedes XML-Element in Scala ist vom Typ <code>Node</code> - einem NodeSeq.
            }-->
        }

        <!-- ################################################################################## -->

        @defining("Auslesen") { title =>

            @slide(title = title, subtitle = "XPath", subsubtitle = "") {
                @sidebyside((35,60)) {
                    @parsecode("xpath")
                } {
                    @snippet(clazz = "slim") {
                        @callblock(reference = "xpath") {
                            |html \ "body"
                        }
                        @outblock() {
                            |res0: scala.xml.NodeSeq = NodeSeq(&lt;body&gt; ...)
                        }
                        @callblock() {
                            |html \ "ul"
                        }
                        @outblock() {
                            |res1: scala.xml.NodeSeq = NodeSeq()
                        }
                    }
                    @codesub2() {
                        Operator <code>\</code> extrahiert direkte Sub-Elemente
                    }

                    @spacer_half()

                    @snippet(clazz = "slim") {
                        @callblock(reference = "xpath") {
                            |(html \\ "li").length
                        }
                        @outblock() {
                            |res0: Int = 6
                        }
                    }
                    @codesub2() {
                        Operator <code>\\</code> extrahiert alle Sub-Elemente
                    }

                    @spacer_half()

                    @snippet(clazz = "slim") {
                        @callblock(reference = "xpath") {
                            |(html \ "body" \ "_" \ "li").length
                        }
                        @outblock() {
                            |res0: Int = 6
                        }
                    }
                    @codesub2() {
                         Wildcard <code>"_"</code> trifft auf alle Elemente zu
                    }

                    @spacer_half()

                    @snippet(clazz = "slim") {
                        @callblock(reference = "xpath") {
                            |html \ "body" \\ "@@class"
                        }
                        @outblock() {
                            |res0: scala.xml.NodeSeq = NodeSeq(clrfix, center, center)
                        }
                    }
                    @codesub2() {
                        <code>@@</code> extrahiert das Attribut
                    }
                }
            }

            <!-- ################################################################################## -->

            @slide(title = title, subtitle = "XPath", subsubtitle = "") {
                @sidebyside((40,60)) {
                    @parsecode("")
                } {
                    @snippet(clazz = "slim") {
                        @callblock(reference = "xpath") {
                            |(html \\ "li")(1)
                        }
                        @outblock() {
                            |res0: scala.xml.Node = &lt;i&gt; Scala &lt;/li&gt;
                        }
                    }
                    @codesub2() {
                        <code>Node</code> ist eine Sequenz
                    }

                    @spacer_half()

                    @snippet(clazz = "slim") {
                        @callblock(reference = "xpath") {
                            |(html \\ "li") map { _.text.trim }
                        }
                        @outblock() {
                            |res0: Seq[String] = List("Java", "Scala", "Groovy",
                            |                         "C#", "F#", "JScript")
                        }
                    }
                    @codesub2() {
                        <code>text</code> liefert Inhalt des XML-Elements
                    }

                    @spacer_half()

                    @snippet(clazz = "slim") {
                        @callblock(reference = "xpath") {
                            |for (e <- html \ "body" \ "_") println(e.label)
                        }
                        @outblock() {
                            |ul
                            |ol
                        }
                    }
                    @codesub2() {
                        <code>label</code> liefert den Tag-Namen des XML-Elements
                    }

                    @spacer_half()

                    @snippet(clazz = "slim") {
                        @callblock(reference = "xpath") {
                            |(html \ "body" \ "_") map (_.attributes)
                        }
                        @outblock() {
                            |res0: Seq[MetaData] = List(class="center",
                            |                          class="center")
                        }
                    }
                    @codesub2() {
                        <code>attributes</code> liefert die Meta-Daten des XML-Elements
                    }
                }
            }

            <!-- ################################################################################## -->

            @*@slide(title = title, subtitle = "Pattern Matching") {
                @sidebyside((40,60)) {
                    @parsecode("pmatch")
                } {
                    @snippet() {
                        @sourceblock(reference = "pmatch") {
                            |def hasClass(n: Node, cls: String): Unit =
                            |  n match {
                            |    case n if (n.attributes("class").text == cls) =>
                            |      print(n.label)
                            |    case _ => n foreach (hasClass(_, cls))
                            |  }
                            |
                        }
                        @callblock() {
                            |hasClass(html, "center")
                        }
                        @outblock() {
                            |ul
                            |ol
                        }
                    }
                    @codesub() {

                    }

                    @spacer()

                    @snippet() {
                        @sourceblock(reference = "pmatch") {
                            |def printElem(n: Node, p: (Elem) => Boolean): Unit =
                            |  n match {
                            |    case e: Elem if(p(e)) => println(e.text.trim)
                            |    case _ => n map (printElem(_, p))
                            |  }
                        }
                        @callblock() {
                            |printElem(html, _.text contains "#")
                        }
                        @outblock() {
                            |C#
                            |F#
                        }
                    }
                    @codesub() {

                    }
                }
                @spacer()
            }

            <!-- ################################################################################## -->

            @slide(title = title, subtitle = "Pattern Matching") {
                @sidebyside((40,60)) {
                    @parsecode("")
                } {
                    @snippet() {
                        @sourceblock(reference = "pmatch") {
                            |def describe(n: Node): String =
                            |  n match {
                            |    case &lt;ol&gt;{_}&lt;/ol&gt; => "ordered list with "
                            |    case &lt;ul&gt;{_}&lt;/ul&gt; => "unordered list with "
                            |    case _ => "unknown"
                            |  }
                        }
                        @callblock() {
                            |(html \ "body" \ "_") map { describe(_) } foreach println
                        }
                        @outblock() {
                            |"ordered list with "
                            |"unordered list with "
                        }
                    }
                    @codesub() {

                    }
                }
                @spacer()
            }*@

            <!-- ################################################################################## -->

            @slide(title = title, subtitle = "Anwendungsbeispiel") {
                @snippet(id = "books_in") {
                    @sourceblock() {
                        |case class Book ( title: String, pages: Int,
                        |                  year: Int, available: Boolean )
                        |
                        |object Book {
                        |
                        |  def apply ( xml: scala.xml.NodeSeq ): Book = {
                        |    val avble = (xml \\ "@@available").text == "true"
                        |    val title = (xml \\ "title").text
                        |    val pages = (xml \\ "pages").text.toInt
                        |    val year  = (xml \\ "year" ).text.toInt
                        |
                        |    new Book (title, pages, year, avble)
                        |  }
                        |}
                    }
                }
                @spacer()
                @snippet() {
                    @callblock(reference = "books_in") {
                        |Book(&lt;book available="true"&gt;
                        |       &lt;title&gt;Programming in Scala&lt;/title&gt;
                        |       &lt;pages&gt;883&lt;/pages&gt;
                        |       &lt;year&gt;2008&lt;/year&gt;
                        |     &lt;/book&gt;)
                    }
                    @outblock() {
                        |res0: Book = Book(Programming in Scala,883,2008,true)
                    }
                }
            }
        }

        <!-- ################################################################################## -->

        @defining("Transformieren") { title =>
            @slide(title = title) {
                @sidebyside((40,60)) {
                    @snippet() {
                        @sourcecode(id = "transform") {
                            |val html =
                            |  &lt;html&gt;
                            |    &lt;body&gt;
                            |      &lt;ul&gt; // unordered
                            |        &lt;li&gt; Java &lt;/li&gt;
                            |        &lt;li&gt; Scala &lt;/li&gt;
                            |      &lt;/ul&gt;
                            |      &lt;ol&gt; // ordered
                            |        &lt;li&gt; C# &lt;/li&gt;
                            |        &lt;li&gt; F# &lt;/li&gt;
                            |      &lt;/ol&gt;
                            |    &lt;/body&gt;
                            |  &lt;/html&gt;
                        }
                        @outblock() {
                            |  &lt;html&gt;
                            |    &lt;body&gt;
                            |      &lt;ol&gt; // ordered
                            |        &lt;li&gt; Java &lt;/li&gt;
                            |        &lt;li&gt; Scala &lt;/li&gt;
                            |      &lt;/ol&gt;
                            |      &lt;ul&gt; // unordered
                            |        &lt;li&gt; C# &lt;/li&gt;
                            |        &lt;li&gt; F# &lt;/li&gt;
                            |      &lt;/ul&gt;
                            |    &lt;/body&gt;
                            |  &lt;/html&gt;
                        }
                    }
                } {
                    @snippet() {
                        @sourceblock(reference = "transform") {
                            |import scala.xml._
                            |import scala.xml.transform._
                            |
                            |val trfrm = new RewriteRule {
                            |  override def transform (n: Node) =
                            |    n match {
                            |      case e: Elem if(e.label == "ul") =>
                            |        e.copy(label = "ol")
                            |      case e: Elem if(e.label == "ol") =>
                            |        e.copy(label = "ul")
                            |      case _ => n
                            |    }
                            |}
                        }
                        @callblock() {
                            |val rt = new RuleTransformer (trfrm)
                            |rt.transform (html)
                        }
                    }
                    @codesub() {
                        <code>RuleTransformer</code> kann eine oder mehrere <code>RewriteRule</code>
                        auf einen <code>Node</code> und dessen Sub-Elemente anwenden
                    }
                }
                @spacer()
            }
        }

        <!-- ################################################################################## -->

        @defining("Speichern und Laden") { title =>
            @slide(title = title) {
                @snippet() {
                    @sourceblock() {
                        |val xml =
                        |   &lt;ul&gt;
                        |       &lt;li&gt;Milk&lt;/li&gt;
                        |       &lt;li&gt;Butter&lt;/li&gt;
                        |       &lt;li&gt;Honey&lt;/li&gt;
                        |   &lt;/ul&gt;
                    }
                    @outblock() {
                        |xml: scala.xml.Elem =
                        |   &lt;ul&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;li&gt;Butter&lt;/li&gt; &lt;li&gt;Honey&lt;/li&gt; &lt;/ul&gt;
                    }
                    @callblock(id = "save") {
                        |scala.xml.XML.save("shoppinglist.xml", xml)
                    }
                }
                @codesub2() {
                    Objekt <code>XML</code> bietet eine <code>save</code>-Methode zum Serialisieren einer <code>Node</code>-Instanz
                }

                @spacer()

                @snippet() {
                    @callblock(reference = "save") {
                        |scala.xml.XML.loadFile("shoppinglist.xml")
                    }
                    @outblock() {
                        |res0: scala.xml.Elem =
                        |   &lt;ul&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;li&gt;Butter&lt;/li&gt; &lt;li&gt;Honey&lt;/li&gt; &lt;/ul&gt;
                    }
                }
                @codesub2() {
                    <code>loadFile</code> kann eine Datei laden und parst den Inhalt mit Hilfe von Javas <em>SAX Parser</em>
                }
            }
        }

        <!-- ################################################################################## -->

        @uebung(implicitSlide.id)
    }
}

@parsecode(id: String) = {
    @sourcecode(id = id) {
        |import xml._
        |
        |val html =
        | &lt;html&gt;
        |
        |  &lt;body class="clrfix"&gt;
        |
        |   &lt;ul class="center"&gt;
        |     &lt;li&gt; Java &lt;/li&gt;
        |     &lt;li&gt; Scala &lt;/li&gt;
        |     &lt;li&gt; Groovy &lt;/li&gt;
        |   &lt;/ul&gt;
        |
        |   &lt;ol class="center"&gt;
        |     &lt;li&gt; C# &lt;/li&gt;
        |     &lt;li&gt; F# &lt;/li&gt;
        |     &lt;li&gt; JScript &lt;/li&gt;
        |   &lt;/ol&gt;
        |
        |  &lt;/body&gt;
        |
        | &lt;/html&gt;
    }
}